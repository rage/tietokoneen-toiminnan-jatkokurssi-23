{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-5/4-optimoitu-koodi","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":" Optimoitu koodi on nopeampi suorittaa kuin optimoimaton koodi. Miksi emme siis aina käyttäisi optimoitua koodia? "}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Optimoidun koodin tarkoitus"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tietokoneohjelmien suoritusnopeus on monissa sovelluksissa hyvin tärkeää. Esimerkiksi sääennustemallin ratkaisu pitäisi pystyä laskemaan muutamassa tunnissa, jotta sääennuste on valmis ajoissa ennen mahdollisen myrskyn saapumista. Toinen hyvä esimerkki on tietokonepelit, joissa vaaditaan huima määrä laskentaa reaaliaikaisen pelitilanteen ylläpitämiseksi ja sen näyttämiseen pelaajalle."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ohjelman koodi voidaan toteuttaa hyvin monella eri tavalla ja joidenkin suoritusaika on pienempi kuin toisilla. Koodin optimoinnilla tarkoitetaan juuri tätä. Yleisesti ottaen, koodin optimointi on vaikeaa ja korkean tason kielten kääntäjät voivat helposti käyttää yli puolet ajastaan koodin optimointiin. Nykyisten suorittimien monimutkaisuuden vuoksi optimointiin ei riitä, että optimointi tapahtuu konekäskyjen tasolla. Optimointi perustuu usein myös käytössä olevan suorittimen erityispiirteisiin, kuten kuinka konekäskyt on toteutettu suorittimessa, kuinka useaa konekäskyä voidaan suorittaa rinnakkain ja kuinka nopeasti muistinviittaukset tapahtuvat. Ongelmakenttä on monimuotoinen ja käsittelemme sitä tässä vain pintapuolisesti."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Optimoinnin vaatiman käännösajan vuoksi useissa suurissa ohjelmistoprojekteissa koodi käännetään ohjelmiston kehitysaikana ilman optimointia. Ohjelmiston valmistuttua se käännetään sitten hyvin optimoiduksi koodiksi, jotta lopputuote toimisi mahdollisimman nopeasti."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Optimoidun koodin toteutus"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koodin optimointia tehdään usealla eri tasolla. Tavoite koodin optimoinnilla on aina tuottaa koodia, jonka suoritusaika olisi mahdollisimman pieni. Tämän takia yleensä pyritään suorittamaan mahdollisimman vähän konekäskyjä ja mahdollisimman vähän muistiviitteitä. Viimeksi mainittuun tavoitteeseen sisältyy sellainen koodi, joka ottaa täyden hyödyn irti välimuistista."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joissakin tapauksissa koodin suoritusajan optimoinnissa otetaan huomioon myös generoidun koodin koko, koska joissakin tapauksissa tehokas suoritusaikaan kohdistuva optimointi voi kasvattaa koodin kokoa huomattavasti. Optimointi voidaan tällöin tehdä niin, että koodin koko ei saa kasvaa \"liikaa\". Toisaalta taas joihinkin pieniin laitteisiin optimointi voidaan toteuttaa siten, että tarkoituksena onkin vain mahdollisimman pieni koodin koko ja suoritusaika ei ole niin tärkeä. Emme käsittele näitä tapauksia tällä kurssilla sen enempää."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Register_allocation","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Rekistereiden allokointi"}]},{"type":"text","value":" on yksi tärkeimmistä (suoritusajan) optimoinnin osa-alueista. Rekistereiden allokoinnissa päätetään, mihin tarkoitukseen kutakin rekisteriä käytetään milloinkin ohjelman suoritusaikana. Säilytetäänkö esimerkiksi muuttujan X arvoa tietyssä vaiheessa (esimerkiksi silmukan sisällä) vaikkapa rekisterissä r3, vai ainoastaan muistissa? Silmukan muuntelumuuttujan arvo olisi usein kätevää pitää rekisterissä, mutta onko nyt juuri vapaata rekisteriä sitä varten? Allokointiongelman ydin on siinä, että rekistereitä on vähän ja viitattavaa dataa paljon. Kaikki laskentatyö pitää kuitenkin tehdä rekistereiden avulla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Eräs optimoinnin kohde on indeksitarkistusten poisjättäminen silloin, kun turvallisuus ei siitä kärsi. On helppo havaita, että silmukassa"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"for (i=0 to 99999) {\n   ...\n   T[i] = ...\n   ...\n   }"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"taulukkoviite T[i] on turvallinen, jos taulukon T koko on ainakin 100000 ja i:n arvoa ei muuteta muualla silmukassa. Tämän päättelyn tekeminen algoritmisesti on kuitenkin yleisessä tapauksessa vaikeaa. Silmukka voi olla koodimäärältään hyvinkin suuri, siinä voi olla viittauksia muualle koodiin ja viitattavan taulukon koko voi olla vaikea päätellä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tarkastellaan yksinkertaista taulukon alustussilmukkaa esimerkkinä optimoinnin toteutuksesta."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"for (i=0 to 499)\n   T[i] = X;"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Se voisi ilman optimointia kääntyä konekieliseksi koodiksi"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"      load  r5, =0    ; alusta i\n      store r5, i\n\nLoop  load r1, i      ; silmukan runko\n      load r2, X\n      store r2, T(r1)\n\n      load r3, i       ; kasvata i\n      add  r3, =1\n      store r3, i\n\n      load r4, i       ; silmukan lopetustesti\n      comp r4, =500\n      jles  Loop"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tämä koodi tuottaa täsmälleen oikean lopputuloksen eli se on virheetön. Kääntäjän tuottama optimoimaton koodi voisi hyvinkin näyttää tältä, koska se on helppo generoida. Siinä on kuitenkin suoritusnopeuden kannalta useita huonoja piirteitä. Koodi käyttää viittä työrekisteriä (r1-r5), joten niillä ei voi olla mitään muuta käyttöä samanaikaisesti. Muuttujan i arvo pidetään koko ajan muistissa, joten siihen kohdistuu valtava määrä muistiviitteitä. Osa muistiviitteistä on ihan turhia, kun tarvittava arvo on jo valmiiksi jossain rekisterissä. Lopetustesti perustuu vertailuun lukuun 500, joten vertailu ja sitä seuraava ehdollinen hyppykäsky vaativat aina kaksi konekäskyä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Saman taulukon alustuksen voisi toteuttaa optimoidulla koodilla"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"      load  r1,=499   ; i:n viimeinen arvo r1:ssä\n      load  r2, X     ; r2 = X (vakio)\nLoop  store r2, T(r1)\n      sub   r1,=1\n      jnneg Loop\n      store r1, i  ; jos ohjelmointi kielen semantiikka vaatii tätä"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Optimoidussa koodissa tarvitaan vain kaksi rekisteriä. Siinä suoritetaan yhteensä 500*3+3=1503 konekäskyä, kun alkuperäinen koodi tarvitsi 500*9+3=4503 konekäskyä. Optimoitu koodi teki 502 muistiviitettä, kun alkuperäinen koodi vaati 3001 muistiviitettä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edellisessä esimerkissä optimoitu koodi oli huomattavasti lyhyempi kuin optimoimaton koodi (6 konekäskyä vs. 11 konekäskyä). Näin ei aina kuitenkaan ole. Taulukon alustuksen voisi toteuttaa vieläkin nopeammin käyttäen ns. \"silmukan purkua\", jossa 2 tai useampi silmukan suorituskerta on yhdistetty. Näin silmukan suorituskertojen määrä saada pienemmäksi ja (käsky)välimuistin toiminta tehokkaammaksi."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"      load  r1, =T   ; r1 = alustettavan alkion osoite\n      load  r2, X    ; r2 = X (vakio)\n      load r3, =499  ; vielä alustettavien alkioiden lukumäärä\nLoop  store r2, 0(r1)\n      store r2, 1(r1)\n      store r2, 2(r1)\n      store r2, 3(r1)\n      add   r1, =4    ; seuraavaksi alustettavien neljän alkion osoite\n      sub   r3, =4\n      jnneg r3, Loop"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Taulukkoon viittaaminen perustuu osoitinmuuttujaan (pointteriin) jota säilytetään rekisterissä r1, eikä indeksointiin, joten lukumäärää varten tarvitaan yksi ylimääräinen rekisteri (r3). Suoritettavia konekäskyjä on vain 125*6+3=903, mutta koodin pituus on liki kaksinkertainen eli 10 käskyä. Tällä on jonkin verran merkitystä, koska suurempien ohjelmien lataus kestää pidempään ja ne tarvitsevat enemmän muistia. Toisaalta suoritusaikainen nopeushyöty on merkittävä. Tämä on esimerkki yleisestä tila/aika-optimoinnista, jossa suoritusaikaa on optimoitu tilan (muisti, rekisterit) kustannuksella. Ääritapauksessa silmukan voisi kokonaan purkaa 500 peräkkäiseen store-käskyyn, mutta olisiko se optimaalista? Koodin koko ainakin kasvaisi valtavasti. Entä sitten, jos looppi pitäisikin suorittaa 10000 kertaa?"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Optimoinnilla voidaan siis saavuttaa huomattava nopeushyöty. Joissakin sovelluksissa hitaampikin vauhti riittää, kuten esimerkiksi tekstinkäsittelyssä. Suoritusnopeuden tarvitsee olla riittävän nopea sovelluksen tarkoitukseen, mutta ei sen nopeampi. On kuitenkin paljon sovelluksia, joiden kohdalla kannattaa ilman muuta satsata kunnolla suoritusnopeuden optimointiin. Sään ennustemallien käyttökin olisi ihan erilaista, jos malli ratkeaisi viidessä minuutissa kahden tunnin asemesta."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koodin suoritusnopeuteen liittyy nykyjärjestelmissä myös monen suorittimen (tai \"ytimen\") käyttö yhden ohjelman suoritukseen. Emme käsittele näitä moniprosessorijärjestelmiä tai niiden ohjelmointia tällä kurssilla lainkaan."}]}]},"html":"<div><div>\n<lead> Optimoitu koodi on nopeampi suorittaa kuin optimoimaton koodi. Miksi emme siis aina käyttäisi optimoitua koodia? </lead>\n</div><h2>Optimoidun koodin tarkoitus</h2><p>Tietokoneohjelmien suoritusnopeus on monissa sovelluksissa hyvin tärkeää. Esimerkiksi sääennustemallin ratkaisu pitäisi pystyä laskemaan muutamassa tunnissa, jotta sääennuste on valmis ajoissa ennen mahdollisen myrskyn saapumista. Toinen hyvä esimerkki on tietokonepelit, joissa vaaditaan huima määrä laskentaa reaaliaikaisen pelitilanteen ylläpitämiseksi ja sen näyttämiseen pelaajalle.</p><p>Ohjelman koodi voidaan toteuttaa hyvin monella eri tavalla ja joidenkin suoritusaika on pienempi kuin toisilla. Koodin optimoinnilla tarkoitetaan juuri tätä. Yleisesti ottaen, koodin optimointi on vaikeaa ja korkean tason kielten kääntäjät voivat helposti käyttää yli puolet ajastaan koodin optimointiin. Nykyisten suorittimien monimutkaisuuden vuoksi optimointiin ei riitä, että optimointi tapahtuu konekäskyjen tasolla. Optimointi perustuu usein myös käytössä olevan suorittimen erityispiirteisiin, kuten kuinka konekäskyt on toteutettu suorittimessa, kuinka useaa konekäskyä voidaan suorittaa rinnakkain ja kuinka nopeasti muistinviittaukset tapahtuvat. Ongelmakenttä on monimuotoinen ja käsittelemme sitä tässä vain pintapuolisesti.</p><p>Optimoinnin vaatiman käännösajan vuoksi useissa suurissa ohjelmistoprojekteissa koodi käännetään ohjelmiston kehitysaikana ilman optimointia. Ohjelmiston valmistuttua se käännetään sitten hyvin optimoiduksi koodiksi, jotta lopputuote toimisi mahdollisimman nopeasti.</p><h2>Optimoidun koodin toteutus</h2><p>Koodin optimointia tehdään usealla eri tasolla. Tavoite koodin optimoinnilla on aina tuottaa koodia, jonka suoritusaika olisi mahdollisimman pieni. Tämän takia yleensä pyritään suorittamaan mahdollisimman vähän konekäskyjä ja mahdollisimman vähän muistiviitteitä. Viimeksi mainittuun tavoitteeseen sisältyy sellainen koodi, joka ottaa täyden hyödyn irti välimuistista.</p><p>Joissakin tapauksissa koodin suoritusajan optimoinnissa otetaan huomioon myös generoidun koodin koko, koska joissakin tapauksissa tehokas suoritusaikaan kohdistuva optimointi voi kasvattaa koodin kokoa huomattavasti. Optimointi voidaan tällöin tehdä niin, että koodin koko ei saa kasvaa \"liikaa\". Toisaalta taas joihinkin pieniin laitteisiin optimointi voidaan toteuttaa siten, että tarkoituksena onkin vain mahdollisimman pieni koodin koko ja suoritusaika ei ole niin tärkeä. Emme käsittele näitä tapauksia tällä kurssilla sen enempää.</p><p><a href=\"https://en.wikipedia.org/wiki/Register_allocation\" target=\"_blank\" rel=\"noopener noreferrer\">Rekistereiden allokointi</a> on yksi tärkeimmistä (suoritusajan) optimoinnin osa-alueista. Rekistereiden allokoinnissa päätetään, mihin tarkoitukseen kutakin rekisteriä käytetään milloinkin ohjelman suoritusaikana. Säilytetäänkö esimerkiksi muuttujan X arvoa tietyssä vaiheessa (esimerkiksi silmukan sisällä) vaikkapa rekisterissä r3, vai ainoastaan muistissa? Silmukan muuntelumuuttujan arvo olisi usein kätevää pitää rekisterissä, mutta onko nyt juuri vapaata rekisteriä sitä varten? Allokointiongelman ydin on siinä, että rekistereitä on vähän ja viitattavaa dataa paljon. Kaikki laskentatyö pitää kuitenkin tehdä rekistereiden avulla.</p><p>Eräs optimoinnin kohde on indeksitarkistusten poisjättäminen silloin, kun turvallisuus ei siitä kärsi. On helppo havaita, että silmukassa</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (i=0 to 99999) {\n   ...\n   T[i] = ...\n   ...\n   }</code></pre></div><p>taulukkoviite T[i] on turvallinen, jos taulukon T koko on ainakin 100000 ja i:n arvoa ei muuteta muualla silmukassa. Tämän päättelyn tekeminen algoritmisesti on kuitenkin yleisessä tapauksessa vaikeaa. Silmukka voi olla koodimäärältään hyvinkin suuri, siinä voi olla viittauksia muualle koodiin ja viitattavan taulukon koko voi olla vaikea päätellä.</p><p>Tarkastellaan yksinkertaista taulukon alustussilmukkaa esimerkkinä optimoinnin toteutuksesta.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (i=0 to 499)\n   T[i] = X;</code></pre></div><p>Se voisi ilman optimointia kääntyä konekieliseksi koodiksi</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      load  r5, =0    ; alusta i\n      store r5, i\n\nLoop  load r1, i      ; silmukan runko\n      load r2, X\n      store r2, T(r1)\n\n      load r3, i       ; kasvata i\n      add  r3, =1\n      store r3, i\n\n      load r4, i       ; silmukan lopetustesti\n      comp r4, =500\n      jles  Loop</code></pre></div><p>Tämä koodi tuottaa täsmälleen oikean lopputuloksen eli se on virheetön. Kääntäjän tuottama optimoimaton koodi voisi hyvinkin näyttää tältä, koska se on helppo generoida. Siinä on kuitenkin suoritusnopeuden kannalta useita huonoja piirteitä. Koodi käyttää viittä työrekisteriä (r1-r5), joten niillä ei voi olla mitään muuta käyttöä samanaikaisesti. Muuttujan i arvo pidetään koko ajan muistissa, joten siihen kohdistuu valtava määrä muistiviitteitä. Osa muistiviitteistä on ihan turhia, kun tarvittava arvo on jo valmiiksi jossain rekisterissä. Lopetustesti perustuu vertailuun lukuun 500, joten vertailu ja sitä seuraava ehdollinen hyppykäsky vaativat aina kaksi konekäskyä.</p><p>Saman taulukon alustuksen voisi toteuttaa optimoidulla koodilla</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      load  r1,=499   ; i:n viimeinen arvo r1:ssä\n      load  r2, X     ; r2 = X (vakio)\nLoop  store r2, T(r1)\n      sub   r1,=1\n      jnneg Loop\n      store r1, i  ; jos ohjelmointi kielen semantiikka vaatii tätä</code></pre></div><p>Optimoidussa koodissa tarvitaan vain kaksi rekisteriä. Siinä suoritetaan yhteensä 500*3+3=1503 konekäskyä, kun alkuperäinen koodi tarvitsi 500*9+3=4503 konekäskyä. Optimoitu koodi teki 502 muistiviitettä, kun alkuperäinen koodi vaati 3001 muistiviitettä.</p><p>Edellisessä esimerkissä optimoitu koodi oli huomattavasti lyhyempi kuin optimoimaton koodi (6 konekäskyä vs. 11 konekäskyä). Näin ei aina kuitenkaan ole. Taulukon alustuksen voisi toteuttaa vieläkin nopeammin käyttäen ns. \"silmukan purkua\", jossa 2 tai useampi silmukan suorituskerta on yhdistetty. Näin silmukan suorituskertojen määrä saada pienemmäksi ja (käsky)välimuistin toiminta tehokkaammaksi.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      load  r1, =T   ; r1 = alustettavan alkion osoite\n      load  r2, X    ; r2 = X (vakio)\n      load r3, =499  ; vielä alustettavien alkioiden lukumäärä\nLoop  store r2, 0(r1)\n      store r2, 1(r1)\n      store r2, 2(r1)\n      store r2, 3(r1)\n      add   r1, =4    ; seuraavaksi alustettavien neljän alkion osoite\n      sub   r3, =4\n      jnneg r3, Loop</code></pre></div><p>Taulukkoon viittaaminen perustuu osoitinmuuttujaan (pointteriin) jota säilytetään rekisterissä r1, eikä indeksointiin, joten lukumäärää varten tarvitaan yksi ylimääräinen rekisteri (r3). Suoritettavia konekäskyjä on vain 125*6+3=903, mutta koodin pituus on liki kaksinkertainen eli 10 käskyä. Tällä on jonkin verran merkitystä, koska suurempien ohjelmien lataus kestää pidempään ja ne tarvitsevat enemmän muistia. Toisaalta suoritusaikainen nopeushyöty on merkittävä. Tämä on esimerkki yleisestä tila/aika-optimoinnista, jossa suoritusaikaa on optimoitu tilan (muisti, rekisterit) kustannuksella. Ääritapauksessa silmukan voisi kokonaan purkaa 500 peräkkäiseen store-käskyyn, mutta olisiko se optimaalista? Koodin koko ainakin kasvaisi valtavasti. Entä sitten, jos looppi pitäisikin suorittaa 10000 kertaa?</p><p>Optimoinnilla voidaan siis saavuttaa huomattava nopeushyöty. Joissakin sovelluksissa hitaampikin vauhti riittää, kuten esimerkiksi tekstinkäsittelyssä. Suoritusnopeuden tarvitsee olla riittävän nopea sovelluksen tarkoitukseen, mutta ei sen nopeampi. On kuitenkin paljon sovelluksia, joiden kohdalla kannattaa ilman muuta satsata kunnolla suoritusnopeuden optimointiin. Sään ennustemallien käyttökin olisi ihan erilaista, jos malli ratkeaisi viidessä minuutissa kahden tunnin asemesta.</p><p>Koodin suoritusnopeuteen liittyy nykyjärjestelmissä myös monen suorittimen (tai \"ytimen\") käyttö yhden ohjelman suoritukseen. Emme käsittele näitä moniprosessorijärjestelmiä tai niiden ohjelmointia tällä kurssilla lainkaan.</p></div>","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}},"allPages":{"edges":[{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}