{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-10/2-java-virtuaalikone","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Tässä aliluvussa (10.2) esittelemme pääpiirteet Java-ohjelmien suorittamisesta Java virtuaalikoneen (JVM) avulla. Käymme läpi JVM:n perusrakenteen ja sen konekielen (Javan tavukoodi, Bytekode) käskytyypit. Tarkoitus ei ole antaa tyhjentävää esitystä JVM:stä, vaan esittää yleiskuva. Seuraavassa aliluvussa (10.3) käymme läpi vähän tarkemmin erilaiset tavat toteuttaa JVM ja kuinka Java-ohjelmien suoritetaan niissä. "}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Java","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Java"}]},{"type":"text","value":" on korkean tason luokkaperustainen olio-ohjelmointikieli. Java-kieliset ohjelmat voisi kääntää ja linkittää ajomoduuleiksi samalla tavalla kuin edellisessä luvussa 9 esitettiin. Näin ei kuitenkaan yleensä tehdä. Korkean tason kielten kääntäjän toteutuksessa on usein osana välikieli, joka toimii siltana kääntäjän "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"front endin"}]},{"type":"text","value":" ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"back endin"}]},{"type":"text","value":" välillä. Javassa tuo välikieli on nostettu näkyville erityisasemaan. Käännösmoduulit välitetään eteenpäin myös Javan välikielisessä muodossa eikä vain Java-kielisinä käännösmoduuleina tai niiden objektimoduuleina. Dynaamisessa linkityksessä Javan välikieliesitys on nostettu liki samanlaiseen asemaan kuin yleensä ovat dynaamisesti linkitettävät objektimoduulit."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Javan välikieli on nimeltään "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Java_bytecode","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Bytecode"}]},{"type":"text","value":" tai "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Java_bytecode","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Java Bytecode"}]},{"type":"text","value":". Siitä käytetään jatkossa nimiä tavukoodi tai Javan tavukoodi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Javan tavukoodi on hypoteettisen Java virtuaalikoneen ("},{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Java","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"JVM"}]},{"type":"text","value":", Java Virtual Machine) konekieltä, ihan samalla tavalla kuin ttk-91 konekieli on hypoteettisen ttk-91 suorittimen konekieltä. Toisin kuin ttk-91 ja sen konekieli, JVM ja sen tavukoodi ovat täydellisesti määriteltyjä."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"JVM ja pinokone"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Java virtuaalikone on geneerinen suoritin, joka toimii rajapintana kaikille Java-ohjelmien erilaisille suoritusmuodoille. Kun useimmat todelliset suorittimet sisältävät rekistereitä laskutoimituksia varten, niin JVM:ssä kaikki laskentaa perustuu pinoon. Laskutoimitusten argumentit ovat aina pinon pinnalla ja aritmeettis-loogisssa operaatiossa ne korvautuvat laskutoimituksen tuloksella. Tyypillistä tällaisessa "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Stack_machine","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"pinokoneessa"}]},{"type":"text","value":" on, että aritmeettis-loogisissa operaatioissa ei tarvitse nimetä yhtään operandia, koska ne löytyvät oletusarvoisista paikoista pinon pinnalta. Operaation suorituksessa operandit otetaan pois pinosta ja tulos talletetaan pinoon."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Rekisteripohjaiset suorittimet toimivat hyvin eri tavalla. Aritmeettis-loogisissa operaatioissa on yleensä nimetty kolme rekisteriä, joista yksi on tulosrekisteri. Tällä tavoin kummankaan operandin arvoa ei tarvitse tuhota. Ttk-91 suorittimessa aritmeettis-loogisissa operaatioissa oli vain kaksi nimettyä operandia ja tulos talletetaan aina ensimmäisen operandin (rekisterin) päälle."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkki. Katsotaan lausekkeen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"z = (x+y)(x+5)"}]},{"type":"text","value":" toteutusta suorittimilla, joissa aritmeettis-loogisissa operaatioissa on 0, 2 tai 3 operandia. Kolmen operandin esimerkki on "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Load/store_architecture","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"load-store"}]},{"type":"text","value":" arkkitehtuuri, jossa muistiviitekäskyt ovat erillään aritmeettis-loogisista operaatioista."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Pinokone        ttk-91          load-store\n\npush x          load r1, x      load r1, x\npush y          add  r1, y      load r2, y\nadd             load r2, x      load r3, =5\npush x          add r2, =5      add r8, r1, r2\npush 5          mul r1, r2      add r9, r1, r3\nadd             store r1, y     mul r10, r8, r9\nmul                             store r10, z\npop z"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM ei määrittele, onko suorituksessa rinnakkaisuutta vai ei. On täysin mahdollista, että yhdestä prosessista on samanaikaisesti suorituksessa useampi säie. Esimerkiksi kaksi peräkkäistä toisistaan riippumatonta metodin kutsua voisivat olla yhtä aikaa suorituksessa (moniytimisellä) laitteistolla, jos vain käytössä oleva JVM:n toteutus tämän sallii."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Javan virtuaalikone voidaan toteuttaa usealla eri tavalla, mikä tekee tästä mielenkiintoisen ohjelmien suoritusmallin. Suoritettava Java-ohjelma siis käännetään aina ensin tavukoodiksi, jonka jälkeen se suoritetaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"jollain tavalla toteutetulla"}]},{"type":"text","value":" JVM:llä. Periaatteessa on ainakin neljä tapaa toteuttaa JVM ja Java-ohjelmia voi sitten suorittaa noilla kaikilla tavoilla. Suoritustavat esitellään tässä lyhyesti ja seuraavassa aliluvussa tarkemmin."}]},{"type":"comment","value":" Kuva: ch-10-2-java-ohjelmien-suoritus "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/b35a0ab37884c738a9d2e09fca31b04c/ch-10-2-java-ohjelmien-suoritus.svg","alt":"Java-ohjelmien suoritustavat. Keskellä on vaakasuora viiva kuvaamassa Java virtuaalikonetta. Viivan yläpuolella on ylhäällä Java-ohjelma, jossa koodinpätkä  k=i+j. Sen alla on sama ohjelma tavukoodiksi käännettynä, sisältäen tavukoodin käskyt iload i, iload j, iadd ja istore k. Viivan alapuolella on kolme eri laatikkoa kuvaamassa eri suoritustapoja. Vasemmalla on tulkitseminen, jossa Intel Pentium II järjestelmässä suorituksessa oleva Java-tulkki lukee datana tavukoodisia käskyjä viivan yläpuolelta. Keskellä on JVM suoritin, jossa natiivisuorittimena on Java-suoritin ja suorituksessa oleva prosessi on tavukoodisessa esitysmuodossa, joka on luettu koodina viivan yläpuolelta. Oikealla on käännös ja JIT-käännös, joissa viivan yläpuolelta luetaan tavukoodi taas datana ja siiät muokataan kääntämällä ja linkittämällä Intel Pentium II:ssa suoritettava latausmoduuli."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-10-2-java-ohjelmien-suoritus","frombottom":"0","totalheight":"40%"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tulkitseminen tarkoittaa sitä, että käytössä on ohjelma "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"JVM tulkki"}]},{"type":"text","value":" (tulkki, Java tulkki), jossa on kaikki JVM:n rakenteet toteutettu tulkin (ohjelman) tietorakenteina. Java-tulkki lukee datana tavukoodin käskyjä yksi kerrallaan ja sitten toteuttaa käskyjen aiheuttamat muutokset JVM:n tietorakenteissa. Esimerkiksi "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iadd"}]},{"type":"text","value":"-käsky poistaa pinon pinnalta kaksi kokonaislukua ja tallettaa pinon pinnalle niiden summan. Java tulkki on normaali korkean tason kielellä toteutettu ohjelma, joka on käännetty ja linkitetty käytössä olevaan järjestelmään. Järjestelmä voi käyttää mitä tahansa suoritinta, esimerkiksi Intelin Pentium II:sta. Suoritustapa on hyvin samanlainen kuin miten Titokone lukee ttk-91 konekäskyjä ja emuloi niiden aiheuttamia muutoksia simuloiduissa ttk-91 rekistereissa ja muistissa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM:n voi toteuttaa myös suoraan laitteistolla "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"JVM suorittimella"}]},{"type":"text","value":" (Java suorittimella), joka suorittaa tavukoodia konekäskyinä. Tässä tapauksessa latausmoduuli siis sisältää alkuperäisen Java-ohjelman tavukoodisen esityksen ja prosessin suoritusaikana tavukoodi luetaan koodina eikä datana. Tämä vastaa tilannetta, jossa (täydellisesti määritelty) ttk-91 toteutettaisiin oikeasti todellisena suorittimena."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kolmas vaihtoehto on "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kääntää ja linkittää"}]},{"type":"text","value":" ohjelman "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"tavukoodinen"}]},{"type":"text","value":" esitysmuoto \"normaalitapaan\" järjestelmän suorittimen konekielelle. Tämä vaihtoehto muistuttaa eniten edellisessä luvussa kuvattua menettelyä, mutta sitä ei yleensä käytetä. Menetelmä eroaa normaalista kääntämisestä siinä, että käännösmoduulit ovat tavukoodia eivätkä korkean tason kielen koodia."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Neljäs vaihtoehto perustuu "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Just-In-Time käännökseen"}]},{"type":"text","value":", jossa kukin viitattu Javan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"moduuli"}]},{"type":"text","value":" käännetään ja linkitetään paikalleen vasta tarvittaessa. Tämä on vähän samanlaista kuin dynaamisessa linkityksessä, mutta objektimoduulien asemesta uuden moduulin esitysmuotona on tavukoodi. Lähestymistapa on joustavaa, koska tavukoodi on geneeristä, mutta objektimoduulien koodi on aina jollain tietyllä konekielellä. Dynaamisen linkittäjän lisäksi tarvitaan nyt myös tavukoodin kääntäjä natiiviympäristön suorittimelle."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"JVM:n pino"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Java virtuaalikoneessa on "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pino"}]},{"type":"text","value":", jossa on ohjelman tietorakenteet, välitulokset ja aktivaatiotietueita vastaavat "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kehykset"}]},{"type":"text","value":". Pinossa ovat siis mm. kaikki ohjelman käyttämät muuttujat ja laskennan välitulokset. Tämä on hyvin erilainen lähestymistapa kuin todellisissa suorittimissa yleinen tapa säilyttää usein tarvittavien muuttujien arvoja ja laskennan välituloksia nopeissa rekistereissä. Jos JVM toteutetaan rekisterikoneessa, niin toteutusta voi hidastaa se, että kaikki data on (ainakin teoriassa) muistissa olevassa JVM:n pinossa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tavukoodissa on pinolle normaalien \"push/pop\"-käskyjen lisäksi JVM:ssä omat \"push/pop\"-käskynsä myös "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kehyksille"}]},{"type":"text","value":" (JVM:n \"aktivaatiotietueille\") , jolloin niitä ei tarvitse rakentaa ja purkaa sana kerrallaan. Kehysten käyttöä tarkennetaan ihan kohta."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM:n pinon ei tarvitse olla yhtenäisellä muistialueella, vaan se allokoidaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"keosta"}]},{"type":"text","value":" (kuten kaikki muutkin JVM:n tietorakenteet). Pinon koko voi olla rajallinen tai dynaamisesti laajennettavissa, jolloin pinon muistitilan loppuessa sille voidaan varata lisää muistitilaa keosta. Sama pätee kaikkiin muihinkin JVM:n varaamiin tietorakenteisiin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pinoon osoittaa kaksi rekisteriä. SP (stack pointer) osoittaa pinon päällimmäiseen alkioon ja LV (local variables frame) nykykehyksen alkuun ja samalla sen ensimmäiseen paikalliseen muuttujaan. Kumpaankaan näistä rekistereistä (kuten ei muihinkaan JVM:n rekistereistä) ei mitenkään nimetä JVM:n konekäskyissä, vaan kaikki rekisteriviittaukset ovat implisiittisiä. Esimerkiksi add-käsky viittaa dataan aina SP:n kautta, vaikka SP:tä ei mitenkään nimetä konekäskyssä. SP:n käyttö tässä tapauksessa päätellään operaatiokoodista (add)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Allaolevan esimerkin lähtötilanteessa ollaan suorittamassa jotain Javan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"metodia"}]},{"type":"text","value":" (aliohjelmaa), jossa on kolme kokonaislukuarvoista paikallista muuttujaa. Paikallisen muuttujan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" arvo on 111, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"j"}]},{"type":"text","value":":n arvo on 222 ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"k"}]},{"type":"text","value":":n arvo on 700. Ne ovat pinossa tämän kutsukerran kehyksessä, jonka alkuun osoittaa LV. Rekisteri SP osoittaa pinon huipulle. Tavukoodissa seuraavana olevilla käskyillä lasketaan Javan lause \"k=i+j;\". Suoritusaikana tavukoodi on (tietenkin) vain numeerisia tavuja, mutta esimerkin vuoksi se esitetään tässä (myös) tekstuaalisessa muodossa. Koodinpätkän seitsemän tavun heksadesimaaliesityksen ja tekstuaalisen tavukoodin välillä on suoraviivainen vastaavuus."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Tavukoodi tekstuaalisena    tavuina\n          iload i           0x15 0x02      i:n osoite on LV+2\n          iload j           0x15 0x03      j:n osoite on LV+3\n          iadd              0x60\n          istore k          0x36 0x04      k:n osoite on LV+4"}]}]}]},{"type":"comment","value":" Kuva: ch-10-2-yhteenlasku-pinossa "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/ef3de088aa00d78e8f4aafc995187b55/ch-10-2-yhteenlasku-pinossa.svg","alt":"Yhteenlasku pinossa. Viisi eri tilannetta pinon sisällöksi. Aluksi vasemmalla pinossa on päällä arvot 700, 222 ja 111 muuttujien k, j ja i arvoina. Näkyvään pinon osaan osoittaa LV sen pohjalle ja SP sen pinnalle. Muuttujan i osoite on LV+2, j:n osoite LV+3 ja k:n osoite LV+4. Käskyn \"iload i\" jälkeen pinon pinnalle on replikoitu i:n arvo 111. Käskyn \"iload j\" jälkeen pinon pinnalle on replikoitu myös j:n arvo 222. Käskyn iadd jälkeen em. arvot 111 ja 222 on poistettu pinoista ja sinne on laitettu niiden summa 333. Käskyn \"istore k\" jälkeen muuttujan k (osoitteessa LV+4) arvo on muuttunut arvoon 33 ja pinon päällä on nyt arvot 333, 222 ja 111 muuttujien k, j ja i arvoina."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-10-2-yhteenlasku-pinossa","frombottom":"0","totalheight":"40%"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pinokoneiden heikkoutena on, että jokainen aritmeettinen operaatio tuhoaa molemmat operandinsa. Argumenttien arvot täytyy aina kopioida pinon huipulle ennen aritmeettis-loogisia operaatioita ja niiden tulokset täytyy vastaavasti ottaa talteen operaation jälkeen. Lisäksi tarvitaan erilaisia replikointikäskyjä, joilla monistetaan pinon pinnalla olevia arvoja."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Paikallisiin muuttujiin ja muihin tietorakenteisiin viitataan käyttäen niiden suhteellisia osoitteita LV:n suhteen. Tilanne on täysin vastaava kuin ttk-91:ssä aliohjelmien paikallisiin muuttujiin viittaaminen aktivaatiotietueen osoitteen (FP) suhteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ensimmäinen käsky "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload i"}]},{"type":"text","value":" kopioi paikallisen muuttujan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" arvon 111 pinon huipulle ja toinen käsky "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload j"}]},{"type":"text","value":" kopioi vastaavasti paikallisen muuttujan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"j"}]},{"type":"text","value":" arvon 222 pinon huipulle. Yhteenlaskukäsky "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iadd"}]},{"type":"text","value":" ottaa argumentit pois pinosta, laskee niiden summan 333 ja tallettaa sen pinon huipulle. Lopulta pinoon talletuskäsky "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"istore k"}]},{"type":"text","value":" ottaa tuloksen pois pinosta ja tallettaa sen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"k"}]},{"type":"text","value":":n arvoksi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koska "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload"}]},{"type":"text","value":"-käskyn parametrin arvo on useimmiten 0, 1, 2 tai 3, niin niitä varten "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"tavukoodin käskyissä"}]},{"type":"text","value":" on myös omat yhden tavun konekäskynsä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload_0"}]},{"type":"text","value":",  "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload_1"}]},{"type":"text","value":", "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload_2"}]},{"type":"text","value":" ja  "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"iload_3"}]},{"type":"text","value":". Käskyllä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"istore"}]},{"type":"text","value":" on vastaavat optiot, mutta siinäkin vain parametriarvoihin 0-3. Näitä käskyjä käyttäen em. koodinpätkän saisi tavukoodina mahtumaan vain 5 tavuun."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Tavukoodi tekstuaalisena    tavuina\n          iload i           0x1c           i:n osoite on LV+2\n          iload j           0x1d           j:n osoite on LV+3\n          iadd              0x60\n          istore k          0x36 0x04      k:n osoite on LV+4"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tämä näyttää vähän tehottomalta, kun operandeja pitää kopioida pinon pinnalle laskutoimituksia varten, molemmat operandit tuhoutuvat aritmetiikkaoperaatioissa ja kaikki dataviitteet kohdistuvat muistissa olevaan pinoon. Rekisteripohjaisissa suorittimissa JVM:n emulointi onkin vaikeaa, kun suoritinarkkitehtuurien peruslähtökohdat ovat niin erilaisia pinokoneella ja rekisterikoneella."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"JVM:n keko, metodialue ja vakioallas"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM:ssä kaikki muistinhallinta on keskitetty JVM:n omaan kekoon. Aina kun ohjelma tarvitsee lisää muistitilaa (esim. uudelle Javan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"oliolle"}]},{"type":"text","value":" eli luokan ilmentymälle Java-operaatiolla "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":"), niin JVM:n toteutusympäristö varaa sen tästä keosta. Vastaavasti, jos JVM itse tarvitsee lisää muistitilaa (esim. pinoa varten), niin myös se varataan täältä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM:ssä ei ole mitään varatun tilan vapauttamiskäskyä, vaan tila vapautuu uusiokäyttöön "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"automaattisen roskienkeruun"}]},{"type":"text","value":" kautta. Se tarkoittaa, että aika ajoin (a) laskenta pysähtyy, (b) roskienkeruu käynnistyy ja vapauttaa aikaisemmin varatun mutta ei enää käytössä olevan muistitilan ja (c) lopulta laskenta voi jatkua. Roskienkeruu tapahtuu esimerkiksi siten, että ensin merkitään kaikki muistialueet vapaiksi. Sitten käydään läpi kaikki ohjelman ja JVM:n sillä hetkellä käytössä olevat muistialueet merkiten ne samalla varatuiksi. Lopuksi otetaan uusiokäyttöön jäljelle jääneet vapaaksi merkityt alueet. Ymmärrettävästi tämä voi viedä aikaa. Roskienkeruu on ongelmallista, koska se pysäyttää laskennan satunnaisiin aikoihin ja voi kestää pitkäänkin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pinossa on jokaiselle metodin kutsulle sitä vastaava kehys, jonka päällä voi vielä olla siinä metodissa käytössä olevat välitulokset. Pinoa käytetään siis sekä metodin kutsurakenteen toteutukseen että laskennan välitulosten tallentamiseen."}]},{"type":"comment","value":" Kuva: ch-10-2-muistialueet "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/a25ffd6eca13c55402b2814b6b6f1e9c/ch-10-2-muistialueet.svg","alt":"JVM:n muistialueet ja rekisterit. Kolme aluetta: metodialue, pino ja vakioallas. Metodialueen keskellä on jossain metodi B:n koodi ja PC osoittaasinne jonnekin. Pinossa on kehykset pääohjelmalle main, metodille A ja metodille B. Kunkin kehyksen päällä on siihen liityvöät välitulokset. LV osoittaa viimeksi kutsutun metodin B alkuun ja SP osoittaa pinon pinnalle. Oikeall on vakioallas, jonka alkuun osoittaa CPP."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-10-2-muistialueet","frombottom":"0","totalheight":"40%"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JVM:ssä on SP:n ja LV:n lisäksi vain kaksi muuta rekisteriä. Rekisteri PC on tavanomainen paikanlaskuri ja osoittaa seuraavaksi suoritettavaan (tavukoodiseen) käskyyn nykyisessä metodissa. Metodien koodit on talletettu omalle metodialueelleen (JVM Method Area), joka on yhteinen kaikille yhden prosessin säikeille."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Rekisteri CPP (Constant Pool Pointer) osoittaa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"vakioaltaaseen"}]},{"type":"text","value":" (constant pool), jossa on kaikki ohjelman käyttämät vakiot ja muut symboliset viitteet. Vakioaltaan tietoihin viitataan käyttäen niiden suhteellista osoitetta CPP:n suhteen. Jokaiselle Javan luokalle (class) ja liittymälle (interface) on oma vakioaltaansa, joka on suoritusaikainen esitystapa tiedoston "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"class constant pool"}]},{"type":"text","value":" taulukolle. Tämä vastaa vähän symbolitaulua (tai sen osaa). Vakioaltaassa on useita eri tyyppisiä vakioita, kuten esimerkiksi tavalliset literaalit ja suoritusaikana ratkottavat attribuutit dynaamista linkitystä (JIT) varten. Vakioaltaat varataan tietenkin keosta."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos suoritettavia säikeitä on useita, niin kaikilla on omat rekisterinsä, pinonsa ja vakioaltaansa. Niillä on kuitenkin yhteinen metodialue ja keko."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Metodin kutsu"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Metodin kutsukäsky on "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invokevirtual"}]},{"type":"text","value":" ja se luo uuden kehyksen pinoon. Ennen käskyä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invokevirtual"}]},{"type":"text","value":" kutsuja laittaa pinoon viitteen kutsuttavan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"olion"}]},{"type":"text","value":" luokkaan ja parametrien arvot. Käskyssä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invokevirtual"}]},{"type":"text","value":" annetaan parametrina viite kutsuttavaan metodiin ja käskyn "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invokevirtual"}]},{"type":"text","value":" suorituksen jälkeen uusi kehys on valmis."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkki. Tarkastellaan metodia "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":", jossa on paikalliset muuttujat "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":". Metodissa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":" on seuraavana Java-lausetta "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"y=Obj.B(x, 5)"}]},{"type":"text","value":" vastaava tavukoodinen kutsu. Kutsun voisi toteuttaa vaikkapa seuraavalla tavalla."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Metodi A\n\n...\ngetstatic #35       0xb2 0x00 0x23   viite olion Obj luokkaan on CPP+35:ssä\niload  x            0x1b             parametri 1, muuttujan x arvo, osoite LV+1\nbipush 5            0x10 0x05        parametri 2, vakio 5\ninvokevirtual #37   0xb6 0x00 0x25   viite metodiin B on CPP+37:ssä"}]}]}]},{"type":"comment","value":" Kuva: ch-10-2-metodin-kutsu "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/6d43951fd5820f5b0038e71f0e7ec5ad/ch-10-2-metodin-kutsu.svg","alt":"Vasemmalla on pinon alkutilanne ja oikealla pinon tila kutsun \"invokevirtual B\" jälkeen. Alkutilanteessa on metodin A kehys, jonka alkuun osoittaa LV. Metodin A kehyksesä on kentät \"link pointer\", \"parametri 1\", paikalliset muuttujat ml. x ja y, A:n kutsujan PC ja LV. Sen päällä on on kutsuttavan metodin B viite ja parametrit 1 ja 2.  Oikealla puolella metodin A kehyksen päälle on rakennettu metodin B kehys siten, että kutsuttavan metodin B viitteen paikalle on nyt laitettu linkki paluuosoitteeseen ja LV tähän linkkikenttään, joka on samalla metodin B kehyksen ensimmäinen sana. Metodin B kehyksen paikallisissa muuttujissa on myös muuttuja g."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-10-2-metodin-kutsu","frombottom":"0","totalheight":"40%"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkissä käskyn "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invokevirtual"}]},{"type":"text","value":" jälkeen kutsutun metodin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" kehys on valmis. Paluusoite löytyy epäsuorasti osoitteesta LV, parametrit ovat osoitteissa LV+1 ja LV+2, minkä jälkeen pinossa on paikalliset muuttujat. Pinon pinnalla on aikaisemman metodin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":" kehyksen osoite, mitä tarvitaan metodista "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" paluun yhteydessä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oletetaan nyt, että metodi "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" palauttaa arvonaan yhden kokonaisluvun, joka on ennen metodista paluukäskyä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"ireturn"}]},{"type":"text","value":" talletettu pinon pinnalle."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"metodi Obj.B\n\n...\niload  g          0x15  0x08  aseta paluuarvo paikallisesta muuttujasta g, osoite LV+8\nireturn           0xac        palauta paluuarvo ja kontrolli kutsuvaan rutiiniin"}]}]}]},{"type":"comment","value":" Kuva: ch-10-2-metodista-paluu "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/d6d69fdb343c047f730b8340017a311f/ch-10-2-metodista-paluu.svg","alt":"Vasemmalla on pinon alkutilanne ja oikealla pinon tila käskyn \"ireturn\" jälkeen. Vasemmalla tila on täsmälleen sama kuin edellisen kuvan oikealla puolella. Oikealla puolella tila muuten sama, mutta kutsutun metodin parametrit ovat poissa ja metodin B viitteen asemesta siinä kohtaa on nyt metodin B paluuarvo."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-10-2-metodista-paluu","frombottom":"0","totalheight":"40%"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käskyn "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"ireturn"}]},{"type":"text","value":" suorituksessa metodin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" kehyksen tiedoilla palautetaan rekistereiden PC, LV ja SP arvot ennalleen ja kopioidaan paluuarvo pinon huipulle. Metodin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":" suoritus voi nyt jatkua ja ensimmäisenä se tietenkin ottaa paluuarvon talteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Metodin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" käyttö on nyt kokonaisuudessaan seuraavanlainen."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"metodi A\n\n...\ngetstatic #35       0xb2 0x00 0x23   viite olion Obj luokkaan on CPP+35:ssä\niload  x            0x1b             parametri 1, muuttujan x arvo, osoite LV+1\nbipush 5            0x10 0x05        parametri 2, vakio 5\ninvokevirtual #37   0xb6 0x00 0x25   viite metodiin B on CPP+37:ssä\nistore y            0x36 0x04        paluuarvo pinosta muuttujaan y, osoite LV+4\n..."}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tavukoodi"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tarkoituksena ei ole tässä käydä kaikkia "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"tavukoodin käskyjä"}]},{"type":"text","value":" läpi, vaan antaa yleiskuva niistä. Alla käydään kursorisesti läpi tavukoodin tietotyypit, tiedonosoitusmoodit ja erilaiset käskytyypit."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Tietotyypit"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käytössä on 1-, 2-, 4- ja 8-tavuiset kokonaisluvut. Datatyyppien nimet ovat vastaavasti "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"byte"}]},{"type":"text","value":", "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"short"}]},{"type":"text","value":", "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"long"}]},{"type":"text","value":". Negatiiviset luvut esitetään kahden komplementin esitysmuodossa. Pieni 1-2 tavun data pakataan taulukoihin ja niihin viitataan taulukoissa omilla load- ja store-konekäskyillä. Pinossa ja vakioaltaassa kaikki data on kokonaisina sanoina."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Liukuluvut esitetään "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/IEEE_floating_point","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"IEEE liukulukustandardin"}]},{"type":"text","value":" mukaisesti. Tavallinen liukuluku "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"float"}]},{"type":"text","value":" on 4 tavua (32 bittiä) ja kaksoistarkkuuden liukuluku "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"double"}]},{"type":"text","value":" on 8 tavua (64 bittiä)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Merkit esitetään käyttäen etumerkitöntä "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Unicode","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Unicode"}]},{"type":"text","value":" merkistöä, jossa kukin merkki esitetään kahdella tavulla. Merkkijonot talletetaan kekoon ja niiden viitetiedot vakioaltaaseen. JVM:n merkkejä tai merkkijonoja ei käsitellä tämän enempää."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Tiedonosoitusmoodi"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tavukoodissa tiedonosoitus on välitöntä tai indeksoitua. Indeksoidut viitteet ovat suhteessa SP-, LV- tai CPP-rekistereihin, mutta rekisteri määräytyy implisiittisesti konekäskyyn mukaan."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"iadd               0x60             implisiittiset dataviittaukset pinoon, osoitteet SP, SP-1\nbipush 5           0x10 0x05        viite vakioarvoon 5 (välitön operandi)\niconst_1           0x04             implisiittinen viite kokonaislukuvakioon 1\nfconst_1           0x0c             implisiittinen viite liukulukuvakioon 1.0\niload 6            0x15 0x06        viite dataan osoitteessa LV+6 (indeksoitu viite)\ninvokevirtual #37  0xb6 0x00 0x25   viite dataan osoitteessa CPP+37 (indeksoitu viite)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koodiin voi tehdä myös indeksoituja viitteitä suhteessa PC-rekisterin arvoon. Koodiviitteet ovat "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"tavuosoitteita"}]},{"type":"text","value":", koska käskyjen pituudet voivat 1-17 tavua (yleensä 1-3 tavua)."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"invokevirtual #37   0xb6 0x00 0x25   PC saa CPP+37:ssä olevan arvon (metodin osoitteen luokassa)\ngoto -27            0xa7 0x80 0x1B   PC saa arvon PC-27, ehdoton hyppy taaksepäin,\n                                     siirtymän määrä 16-bittisenä etumerkillisenä kokonaislukuna"}]}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Käskytyypit"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käytössä on useita tietotyyppejä ja kussakin aritmeettis-loogisessa operaatiossa argumenttien täytyy olla saman kokoisia ja samaa tyyppiä. Tätä varten käskykannassa on useita datan tyypinmuunnoskäskyjä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"i2b       0x91       muuta 32-bittinen kokonaisluku (word) 8-bittiseksi (byte). Etumerkki!\ni2f       0x86       muuta 32-bittinen kokonaisluku (word) 32-bittiseksi liukuluvuksi (float)\nd2l       0x8f       muuta 64-bittinen liukuluku (double) 64-bittiseksi kokonaisluvuksi (long)\nd2i       0x8e       muuta 64-bittinen liukuluku (double) 32-bittiseksi kokonaisluvuksi (int)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tiedonsiirtokäskyistä on jo esitelty käskyjä, joilla kopioidaan 32-bittinen kokonaisluku pinon pinnalle tai siirretään pinon pinnalla olevaa dataa muualle. Vastaavat käskyjä on eri pituisille data-alkioille ja tietotyypeille. Aritmeettis-loogisten lausekkeiden toteutuksissa pinon pinnalla olevaa dataa tarvitsee usein monistaa tai järjestää uuteen järjestykseen."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"iload_2        0x1c            push (LV+2)     tuo kokonaisluku\nistore 17      0x36 0x11       pop  (LV+17)    vie kokonaisluku\nlload  12      0x16 0x0C       push (LV+12)    tuo pitkä kokonaisluku\nfload  10      0x17 0x0A       push (LV+10)    tuo liukuluku\ndstore 6       0x39 0x06       pop  (LV+6)     vie pitkä liukuluku\naload 3        0x2d 0x03       push (LV+3)     tuo viite (osoite)\ndup            0x59            push (SP)       monista data\ndup_x2         0x5b            push (SP-2)     monista data\ndup2           0x5c            push (SP)       monista pitkä data\nswap           0x5f            swap(SP, SP-1)  vaihda sanat\nbipush 5       0x10 0x05       push (5)        tuo kokonaislukuvakio\niconst_1       0x04            push 1          tuo kokonaislukuvakio\nfconst_1       0x0c            push 1.0        tuo liukulukuvakio\ngetstatic #35  0xb2 0x00 0x23  push (CPP+35)   tuo luokan viite"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Taulukkoviitteet ovat JVM:ssä yllättävän vaikeita. Taulukot talletetaan kekoon ja niiden viitetiedot vakioaltaaseen. Taulukoihin viitataan kehyksen muuttujista. Taulukkoviittauksessa pinoon tuodaan ensin taulukon viite (osoite vakioaltaassa) ja indeksi, minkä jälkeen vasta voidaan tehdä varsinainen viittaus taulukkoon. Esimerkiksi, Java-lauseen \"a=t[i];\" toteutus tavukoodilla voisi olla"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"aload_1         0x2b          push (LV+1)   taulukon viite t (parametrissa 1)\niload_2         0x1c          push (LV+2)   indeksi i (parametrissa 2)\niaload          0x2e          push (t[i])   korvaa t ja i alkion t[i] arvolla\nistore_3        0x3e          pop (LV+3)    taulukon kokonaislukuarvo (paikallinen muuttuja 1)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos taulukko t sisältäisi neljän tavun kokonaislukujen asemesta yhden tavun kokonaislukuja, niin saman lauseen toteutus olisi"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"aload_1         0x2b          push (LV+1)   taulukon viite t\niload_2         0x1c          push (LV+2)   indeksi i\nbaload          0x33          push (t[i])   laajennna tavu samalla sanaksi\nistore_3        0x3e          pop (LV+3)    tallenna kokonaislukuarvo sanana"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kontrollinsiirtokäskyjä on paljon, koska eri tietotyypeille tarvitaan kullekin omat ehdolliset haarautumiskäskynsä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"goto -27            0xa7 0x80 0x1B   PC saa arvon PC-27, ehdoton hyppy taaksepäin\nif_icmpgt  +33      0xa3 0x00 0x21   vertaa pinon arvoja. Jos isompi, niin PC saa arvo PC+33\nif_icmpeq  -27      0x9f 0x80 0x1B   vertaa pinosn arvoja. Jos sama, niin PC saa arvo PC-27\niflt  +33           0x9b 0x00 0x21   jos pinossa oleva arvo <0, niin PC saa arvon PC+33\nlcmp                0x94             vertaa kahta pitkää kokonaislukua, tulos pinoon (+1, 0, -1)\nfcmpg               0x96             vertaa kahta liukulukua, tulos pinoon (+1, 0, -1)\ninvokevirtual #37   0xb6 0x00 0x25   call (CPP+37)\nireturn             0xac             palaa kutsutusta metodista"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Aritmeettis-loogisia operaatioita on vastaavasti useita, koska yhden tai kahden sanan pituusvaihtoehdoille tarvitaan omat käskynsä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"iadd      0x60     kokonaislukujen (int) yhteenlasku\niand      0x7e     and-operaatio pareittain 32-bittisille loogisille arvoille kokonaisluvuissa\ndmul      0x63     64-bittisten liukulukujen yhteenlasku\nldiv      0x6d     64-bittisten kokonaislukujen jakolasku\nlrem      0x71     64-bittisten kokonaislukujen jakolaskun jakojäännös"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lisäksi tavukoodiin sisältyy sekalainen joukko muita käskyjä, joista alla on muutamia esimerkkejä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"nop             0x00               no operation, kuluttaa vähän aikaa\npop             0x57               ota sana pinosta, heitä pois\narraylength     0xbe               pinon päällä viitatun taulukon pituus\nathrow          0xbf               aiheuta keskeytys\nnew  House      0xbb  0x00 0x03    luo uusi House-tyyppinen olio (instanssi)"}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Esimerkki tavukoodin käytöstä"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tarkastellaan Java-kielistä koodinpätkää"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"k = i+5;\n\nif (k=10)\n    j=i;\nelse\n    j=k;"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kokonaislukuarvoiset muuttujat "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"i"}]},{"type":"text","value":", "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"j"}]},{"type":"text","value":" ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"k"}]},{"type":"text","value":" ovat paikallisia muuttujia kehyksen osoitteissa 7, 8 ja 9. Jos tavukoodinen koodinpätkä alkaa tavusta 100 (desimaaliluku), niin tästä voisi generoitua tavukoodi"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"tavukoodi tekstinä       heksadesimaalina\n\nstrt  iload i            100:   0x15 0x07\n      bipush 5           102:   0x10 0x05\n      iadd               104:   0x60\n      dup                105:   0x59             k tarvitaan kohta taas\n      istore k           106:   0x36 0x09\n\n      bipush 10          108:   0x10 0x0A        k oli pinossa jo\n      if_icmpeq else     110:   0x0f 0x00 0x0A   110+10=120\nif10  iload i            113:   0x15 0x07\n      istore j           115:   0x36 0x08\n      goto done          117:   0xa7 0x00 0x07   117+7=124\nelse  iload k            120:   0x15 0x09\n      istore j           122:   0x36 0x08\ndone  nop                124:   0x00"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tavun 105 käsky "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"dup"}]},{"type":"text","value":" käyttö on jo vähän koodin optimointia. Lisäoptimoinnilla koodi voisi ehkä olla vielä tehokkaampi. Esimerkiksi,  "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"istore j"}]},{"type":"text","value":" käskyt voisi yhdistää haarautumisen jälkeen tehtäväksi. Tällöin koodista tulisi kolme tavua lyhyempi, kun nop-käskyäkään ei enää tarvittaisi vain haarautumisen loppuosoitetta varten."}]}]},"html":"<div><div>\n<lead>Tässä aliluvussa (10.2) esittelemme pääpiirteet Java-ohjelmien suorittamisesta Java virtuaalikoneen (JVM) avulla. Käymme läpi JVM:n perusrakenteen ja sen konekielen (Javan tavukoodi, Bytekode) käskytyypit. Tarkoitus ei ole antaa tyhjentävää esitystä JVM:stä, vaan esittää yleiskuva. Seuraavassa aliluvussa (10.3) käymme läpi vähän tarkemmin erilaiset tavat toteuttaa JVM ja kuinka Java-ohjelmien suoritetaan niissä. </lead>\n</div><p><a href=\"https://fi.wikipedia.org/wiki/Java\" target=\"_blank\" rel=\"noopener noreferrer\">Java</a> on korkean tason luokkaperustainen olio-ohjelmointikieli. Java-kieliset ohjelmat voisi kääntää ja linkittää ajomoduuleiksi samalla tavalla kuin edellisessä luvussa 9 esitettiin. Näin ei kuitenkaan yleensä tehdä. Korkean tason kielten kääntäjän toteutuksessa on usein osana välikieli, joka toimii siltana kääntäjän <em>front endin</em> ja <em>back endin</em> välillä. Javassa tuo välikieli on nostettu näkyville erityisasemaan. Käännösmoduulit välitetään eteenpäin myös Javan välikielisessä muodossa eikä vain Java-kielisinä käännösmoduuleina tai niiden objektimoduuleina. Dynaamisessa linkityksessä Javan välikieliesitys on nostettu liki samanlaiseen asemaan kuin yleensä ovat dynaamisesti linkitettävät objektimoduulit.</p><p>Javan välikieli on nimeltään <a href=\"https://en.wikipedia.org/wiki/Java_bytecode\" target=\"_blank\" rel=\"noopener noreferrer\">Bytecode</a> tai <a href=\"https://en.wikipedia.org/wiki/Java_bytecode\" target=\"_blank\" rel=\"noopener noreferrer\">Java Bytecode</a>. Siitä käytetään jatkossa nimiä tavukoodi tai Javan tavukoodi.</p><p>Javan tavukoodi on hypoteettisen Java virtuaalikoneen (<a href=\"https://fi.wikipedia.org/wiki/Java\" target=\"_blank\" rel=\"noopener noreferrer\">JVM</a>, Java Virtual Machine) konekieltä, ihan samalla tavalla kuin ttk-91 konekieli on hypoteettisen ttk-91 suorittimen konekieltä. Toisin kuin ttk-91 ja sen konekieli, JVM ja sen tavukoodi ovat täydellisesti määriteltyjä.</p><h2>JVM ja pinokone</h2><p>Java virtuaalikone on geneerinen suoritin, joka toimii rajapintana kaikille Java-ohjelmien erilaisille suoritusmuodoille. Kun useimmat todelliset suorittimet sisältävät rekistereitä laskutoimituksia varten, niin JVM:ssä kaikki laskentaa perustuu pinoon. Laskutoimitusten argumentit ovat aina pinon pinnalla ja aritmeettis-loogisssa operaatiossa ne korvautuvat laskutoimituksen tuloksella. Tyypillistä tällaisessa <a href=\"https://en.wikipedia.org/wiki/Stack_machine\" target=\"_blank\" rel=\"noopener noreferrer\">pinokoneessa</a> on, että aritmeettis-loogisissa operaatioissa ei tarvitse nimetä yhtään operandia, koska ne löytyvät oletusarvoisista paikoista pinon pinnalta. Operaation suorituksessa operandit otetaan pois pinosta ja tulos talletetaan pinoon.</p><p>Rekisteripohjaiset suorittimet toimivat hyvin eri tavalla. Aritmeettis-loogisissa operaatioissa on yleensä nimetty kolme rekisteriä, joista yksi on tulosrekisteri. Tällä tavoin kummankaan operandin arvoa ei tarvitse tuhota. Ttk-91 suorittimessa aritmeettis-loogisissa operaatioissa oli vain kaksi nimettyä operandia ja tulos talletetaan aina ensimmäisen operandin (rekisterin) päälle.</p><p>Esimerkki. Katsotaan lausekkeen <em>z = (x+y)(x+5)</em> toteutusta suorittimilla, joissa aritmeettis-loogisissa operaatioissa on 0, 2 tai 3 operandia. Kolmen operandin esimerkki on <a href=\"https://en.wikipedia.org/wiki/Load/store_architecture\" target=\"_blank\" rel=\"noopener noreferrer\">load-store</a> arkkitehtuuri, jossa muistiviitekäskyt ovat erillään aritmeettis-loogisista operaatioista.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Pinokone        ttk-91          load-store\n\npush x          load r1, x      load r1, x\npush y          add  r1, y      load r2, y\nadd             load r2, x      load r3, =5\npush x          add r2, =5      add r8, r1, r2\npush 5          mul r1, r2      add r9, r1, r3\nadd             store r1, y     mul r10, r8, r9\nmul                             store r10, z\npop z</code></pre></div><p>JVM ei määrittele, onko suorituksessa rinnakkaisuutta vai ei. On täysin mahdollista, että yhdestä prosessista on samanaikaisesti suorituksessa useampi säie. Esimerkiksi kaksi peräkkäistä toisistaan riippumatonta metodin kutsua voisivat olla yhtä aikaa suorituksessa (moniytimisellä) laitteistolla, jos vain käytössä oleva JVM:n toteutus tämän sallii.</p><p>Javan virtuaalikone voidaan toteuttaa usealla eri tavalla, mikä tekee tästä mielenkiintoisen ohjelmien suoritusmallin. Suoritettava Java-ohjelma siis käännetään aina ensin tavukoodiksi, jonka jälkeen se suoritetaan <em>jollain tavalla toteutetulla</em> JVM:llä. Periaatteessa on ainakin neljä tapaa toteuttaa JVM ja Java-ohjelmia voi sitten suorittaa noilla kaikilla tavoilla. Suoritustavat esitellään tässä lyhyesti ja seuraavassa aliluvussa tarkemmin.</p><!-- Kuva: ch-10-2-java-ohjelmien-suoritus --><p><img src=\"/b35a0ab37884c738a9d2e09fca31b04c/ch-10-2-java-ohjelmien-suoritus.svg\" alt=\"Java-ohjelmien suoritustavat. Keskellä on vaakasuora viiva kuvaamassa Java virtuaalikonetta. Viivan yläpuolella on ylhäällä Java-ohjelma, jossa koodinpätkä  k=i+j. Sen alla on sama ohjelma tavukoodiksi käännettynä, sisältäen tavukoodin käskyt iload i, iload j, iadd ja istore k. Viivan alapuolella on kolme eri laatikkoa kuvaamassa eri suoritustapoja. Vasemmalla on tulkitseminen, jossa Intel Pentium II järjestelmässä suorituksessa oleva Java-tulkki lukee datana tavukoodisia käskyjä viivan yläpuolelta. Keskellä on JVM suoritin, jossa natiivisuorittimena on Java-suoritin ja suorituksessa oleva prosessi on tavukoodisessa esitysmuodossa, joka on luettu koodina viivan yläpuolelta. Oikealla on käännös ja JIT-käännös, joissa viivan yläpuolelta luetaan tavukoodi taas datana ja siiät muokataan kääntämällä ja linkittämällä Intel Pentium II:ssa suoritettava latausmoduuli.\"></p><div>\n<illustrations motive=\"ch-10-2-java-ohjelmien-suoritus\" frombottom=\"0\" totalheight=\"40%\"></illustrations>\n</div><p>Tulkitseminen tarkoittaa sitä, että käytössä on ohjelma <em>JVM tulkki</em> (tulkki, Java tulkki), jossa on kaikki JVM:n rakenteet toteutettu tulkin (ohjelman) tietorakenteina. Java-tulkki lukee datana tavukoodin käskyjä yksi kerrallaan ja sitten toteuttaa käskyjen aiheuttamat muutokset JVM:n tietorakenteissa. Esimerkiksi <em>iadd</em>-käsky poistaa pinon pinnalta kaksi kokonaislukua ja tallettaa pinon pinnalle niiden summan. Java tulkki on normaali korkean tason kielellä toteutettu ohjelma, joka on käännetty ja linkitetty käytössä olevaan järjestelmään. Järjestelmä voi käyttää mitä tahansa suoritinta, esimerkiksi Intelin Pentium II:sta. Suoritustapa on hyvin samanlainen kuin miten Titokone lukee ttk-91 konekäskyjä ja emuloi niiden aiheuttamia muutoksia simuloiduissa ttk-91 rekistereissa ja muistissa.</p><p>JVM:n voi toteuttaa myös suoraan laitteistolla <em>JVM suorittimella</em> (Java suorittimella), joka suorittaa tavukoodia konekäskyinä. Tässä tapauksessa latausmoduuli siis sisältää alkuperäisen Java-ohjelman tavukoodisen esityksen ja prosessin suoritusaikana tavukoodi luetaan koodina eikä datana. Tämä vastaa tilannetta, jossa (täydellisesti määritelty) ttk-91 toteutettaisiin oikeasti todellisena suorittimena.</p><p>Kolmas vaihtoehto on <em>kääntää ja linkittää</em> ohjelman <em>tavukoodinen</em> esitysmuoto \"normaalitapaan\" järjestelmän suorittimen konekielelle. Tämä vaihtoehto muistuttaa eniten edellisessä luvussa kuvattua menettelyä, mutta sitä ei yleensä käytetä. Menetelmä eroaa normaalista kääntämisestä siinä, että käännösmoduulit ovat tavukoodia eivätkä korkean tason kielen koodia.</p><p>Neljäs vaihtoehto perustuu <em>Just-In-Time käännökseen</em>, jossa kukin viitattu Javan <em>moduuli</em> käännetään ja linkitetään paikalleen vasta tarvittaessa. Tämä on vähän samanlaista kuin dynaamisessa linkityksessä, mutta objektimoduulien asemesta uuden moduulin esitysmuotona on tavukoodi. Lähestymistapa on joustavaa, koska tavukoodi on geneeristä, mutta objektimoduulien koodi on aina jollain tietyllä konekielellä. Dynaamisen linkittäjän lisäksi tarvitaan nyt myös tavukoodin kääntäjä natiiviympäristön suorittimelle.</p><h3>JVM:n pino</h3><p>Java virtuaalikoneessa on <em>pino</em>, jossa on ohjelman tietorakenteet, välitulokset ja aktivaatiotietueita vastaavat <em>kehykset</em>. Pinossa ovat siis mm. kaikki ohjelman käyttämät muuttujat ja laskennan välitulokset. Tämä on hyvin erilainen lähestymistapa kuin todellisissa suorittimissa yleinen tapa säilyttää usein tarvittavien muuttujien arvoja ja laskennan välituloksia nopeissa rekistereissä. Jos JVM toteutetaan rekisterikoneessa, niin toteutusta voi hidastaa se, että kaikki data on (ainakin teoriassa) muistissa olevassa JVM:n pinossa.</p><p>Tavukoodissa on pinolle normaalien \"push/pop\"-käskyjen lisäksi JVM:ssä omat \"push/pop\"-käskynsä myös <em>kehyksille</em> (JVM:n \"aktivaatiotietueille\") , jolloin niitä ei tarvitse rakentaa ja purkaa sana kerrallaan. Kehysten käyttöä tarkennetaan ihan kohta.</p><p>JVM:n pinon ei tarvitse olla yhtenäisellä muistialueella, vaan se allokoidaan <em>keosta</em> (kuten kaikki muutkin JVM:n tietorakenteet). Pinon koko voi olla rajallinen tai dynaamisesti laajennettavissa, jolloin pinon muistitilan loppuessa sille voidaan varata lisää muistitilaa keosta. Sama pätee kaikkiin muihinkin JVM:n varaamiin tietorakenteisiin.</p><p>Pinoon osoittaa kaksi rekisteriä. SP (stack pointer) osoittaa pinon päällimmäiseen alkioon ja LV (local variables frame) nykykehyksen alkuun ja samalla sen ensimmäiseen paikalliseen muuttujaan. Kumpaankaan näistä rekistereistä (kuten ei muihinkaan JVM:n rekistereistä) ei mitenkään nimetä JVM:n konekäskyissä, vaan kaikki rekisteriviittaukset ovat implisiittisiä. Esimerkiksi add-käsky viittaa dataan aina SP:n kautta, vaikka SP:tä ei mitenkään nimetä konekäskyssä. SP:n käyttö tässä tapauksessa päätellään operaatiokoodista (add).</p><p>Allaolevan esimerkin lähtötilanteessa ollaan suorittamassa jotain Javan <em>metodia</em> (aliohjelmaa), jossa on kolme kokonaislukuarvoista paikallista muuttujaa. Paikallisen muuttujan <em>i</em> arvo on 111, <em>j</em>:n arvo on 222 ja <em>k</em>:n arvo on 700. Ne ovat pinossa tämän kutsukerran kehyksessä, jonka alkuun osoittaa LV. Rekisteri SP osoittaa pinon huipulle. Tavukoodissa seuraavana olevilla käskyillä lasketaan Javan lause \"k=i+j;\". Suoritusaikana tavukoodi on (tietenkin) vain numeerisia tavuja, mutta esimerkin vuoksi se esitetään tässä (myös) tekstuaalisessa muodossa. Koodinpätkän seitsemän tavun heksadesimaaliesityksen ja tekstuaalisen tavukoodin välillä on suoraviivainen vastaavuus.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Tavukoodi tekstuaalisena    tavuina\n          iload i           0x15 0x02      i:n osoite on LV+2\n          iload j           0x15 0x03      j:n osoite on LV+3\n          iadd              0x60\n          istore k          0x36 0x04      k:n osoite on LV+4</code></pre></div><!-- Kuva: ch-10-2-yhteenlasku-pinossa --><p><img src=\"/ef3de088aa00d78e8f4aafc995187b55/ch-10-2-yhteenlasku-pinossa.svg\" alt=\"Yhteenlasku pinossa. Viisi eri tilannetta pinon sisällöksi. Aluksi vasemmalla pinossa on päällä arvot 700, 222 ja 111 muuttujien k, j ja i arvoina. Näkyvään pinon osaan osoittaa LV sen pohjalle ja SP sen pinnalle. Muuttujan i osoite on LV+2, j:n osoite LV+3 ja k:n osoite LV+4. Käskyn &#x22;iload i&#x22; jälkeen pinon pinnalle on replikoitu i:n arvo 111. Käskyn &#x22;iload j&#x22; jälkeen pinon pinnalle on replikoitu myös j:n arvo 222. Käskyn iadd jälkeen em. arvot 111 ja 222 on poistettu pinoista ja sinne on laitettu niiden summa 333. Käskyn &#x22;istore k&#x22; jälkeen muuttujan k (osoitteessa LV+4) arvo on muuttunut arvoon 33 ja pinon päällä on nyt arvot 333, 222 ja 111 muuttujien k, j ja i arvoina.\"></p><div>\n<illustrations motive=\"ch-10-2-yhteenlasku-pinossa\" frombottom=\"0\" totalheight=\"40%\"></illustrations>\n</div><p>Pinokoneiden heikkoutena on, että jokainen aritmeettinen operaatio tuhoaa molemmat operandinsa. Argumenttien arvot täytyy aina kopioida pinon huipulle ennen aritmeettis-loogisia operaatioita ja niiden tulokset täytyy vastaavasti ottaa talteen operaation jälkeen. Lisäksi tarvitaan erilaisia replikointikäskyjä, joilla monistetaan pinon pinnalla olevia arvoja.</p><p>Paikallisiin muuttujiin ja muihin tietorakenteisiin viitataan käyttäen niiden suhteellisia osoitteita LV:n suhteen. Tilanne on täysin vastaava kuin ttk-91:ssä aliohjelmien paikallisiin muuttujiin viittaaminen aktivaatiotietueen osoitteen (FP) suhteen.</p><p>Ensimmäinen käsky <em>iload i</em> kopioi paikallisen muuttujan <em>i</em> arvon 111 pinon huipulle ja toinen käsky <em>iload j</em> kopioi vastaavasti paikallisen muuttujan <em>j</em> arvon 222 pinon huipulle. Yhteenlaskukäsky <em>iadd</em> ottaa argumentit pois pinosta, laskee niiden summan 333 ja tallettaa sen pinon huipulle. Lopulta pinoon talletuskäsky <em>istore k</em> ottaa tuloksen pois pinosta ja tallettaa sen <em>k</em>:n arvoksi.</p><p>Koska <em>iload</em>-käskyn parametrin arvo on useimmiten 0, 1, 2 tai 3, niin niitä varten <a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener noreferrer\">tavukoodin käskyissä</a> on myös omat yhden tavun konekäskynsä <em>iload_0</em>,  <em>iload_1</em>, <em>iload_2</em> ja  <em>iload_3</em>. Käskyllä <em>istore</em> on vastaavat optiot, mutta siinäkin vain parametriarvoihin 0-3. Näitä käskyjä käyttäen em. koodinpätkän saisi tavukoodina mahtumaan vain 5 tavuun.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Tavukoodi tekstuaalisena    tavuina\n          iload i           0x1c           i:n osoite on LV+2\n          iload j           0x1d           j:n osoite on LV+3\n          iadd              0x60\n          istore k          0x36 0x04      k:n osoite on LV+4</code></pre></div><p>Tämä näyttää vähän tehottomalta, kun operandeja pitää kopioida pinon pinnalle laskutoimituksia varten, molemmat operandit tuhoutuvat aritmetiikkaoperaatioissa ja kaikki dataviitteet kohdistuvat muistissa olevaan pinoon. Rekisteripohjaisissa suorittimissa JVM:n emulointi onkin vaikeaa, kun suoritinarkkitehtuurien peruslähtökohdat ovat niin erilaisia pinokoneella ja rekisterikoneella.</p><h3>JVM:n keko, metodialue ja vakioallas</h3><p>JVM:ssä kaikki muistinhallinta on keskitetty JVM:n omaan kekoon. Aina kun ohjelma tarvitsee lisää muistitilaa (esim. uudelle Javan <em>oliolle</em> eli luokan ilmentymälle Java-operaatiolla <em>new</em>), niin JVM:n toteutusympäristö varaa sen tästä keosta. Vastaavasti, jos JVM itse tarvitsee lisää muistitilaa (esim. pinoa varten), niin myös se varataan täältä.</p><p>JVM:ssä ei ole mitään varatun tilan vapauttamiskäskyä, vaan tila vapautuu uusiokäyttöön <em>automaattisen roskienkeruun</em> kautta. Se tarkoittaa, että aika ajoin (a) laskenta pysähtyy, (b) roskienkeruu käynnistyy ja vapauttaa aikaisemmin varatun mutta ei enää käytössä olevan muistitilan ja (c) lopulta laskenta voi jatkua. Roskienkeruu tapahtuu esimerkiksi siten, että ensin merkitään kaikki muistialueet vapaiksi. Sitten käydään läpi kaikki ohjelman ja JVM:n sillä hetkellä käytössä olevat muistialueet merkiten ne samalla varatuiksi. Lopuksi otetaan uusiokäyttöön jäljelle jääneet vapaaksi merkityt alueet. Ymmärrettävästi tämä voi viedä aikaa. Roskienkeruu on ongelmallista, koska se pysäyttää laskennan satunnaisiin aikoihin ja voi kestää pitkäänkin.</p><p>Pinossa on jokaiselle metodin kutsulle sitä vastaava kehys, jonka päällä voi vielä olla siinä metodissa käytössä olevat välitulokset. Pinoa käytetään siis sekä metodin kutsurakenteen toteutukseen että laskennan välitulosten tallentamiseen.</p><!-- Kuva: ch-10-2-muistialueet --><p><img src=\"/a25ffd6eca13c55402b2814b6b6f1e9c/ch-10-2-muistialueet.svg\" alt=\"JVM:n muistialueet ja rekisterit. Kolme aluetta: metodialue, pino ja vakioallas. Metodialueen keskellä on jossain metodi B:n koodi ja PC osoittaasinne jonnekin. Pinossa on kehykset pääohjelmalle main, metodille A ja metodille B. Kunkin kehyksen päällä on siihen liityvöät välitulokset. LV osoittaa viimeksi kutsutun metodin B alkuun ja SP osoittaa pinon pinnalle. Oikeall on vakioallas, jonka alkuun osoittaa CPP.\"></p><div>\n<illustrations motive=\"ch-10-2-muistialueet\" frombottom=\"0\" totalheight=\"40%\"></illustrations>\n</div><p>JVM:ssä on SP:n ja LV:n lisäksi vain kaksi muuta rekisteriä. Rekisteri PC on tavanomainen paikanlaskuri ja osoittaa seuraavaksi suoritettavaan (tavukoodiseen) käskyyn nykyisessä metodissa. Metodien koodit on talletettu omalle metodialueelleen (JVM Method Area), joka on yhteinen kaikille yhden prosessin säikeille.</p><p>Rekisteri CPP (Constant Pool Pointer) osoittaa <em>vakioaltaaseen</em> (constant pool), jossa on kaikki ohjelman käyttämät vakiot ja muut symboliset viitteet. Vakioaltaan tietoihin viitataan käyttäen niiden suhteellista osoitetta CPP:n suhteen. Jokaiselle Javan luokalle (class) ja liittymälle (interface) on oma vakioaltaansa, joka on suoritusaikainen esitystapa tiedoston <em>class constant pool</em> taulukolle. Tämä vastaa vähän symbolitaulua (tai sen osaa). Vakioaltaassa on useita eri tyyppisiä vakioita, kuten esimerkiksi tavalliset literaalit ja suoritusaikana ratkottavat attribuutit dynaamista linkitystä (JIT) varten. Vakioaltaat varataan tietenkin keosta.</p><p>Jos suoritettavia säikeitä on useita, niin kaikilla on omat rekisterinsä, pinonsa ja vakioaltaansa. Niillä on kuitenkin yhteinen metodialue ja keko.</p><h3>Metodin kutsu</h3><p>Metodin kutsukäsky on <em>invokevirtual</em> ja se luo uuden kehyksen pinoon. Ennen käskyä <em>invokevirtual</em> kutsuja laittaa pinoon viitteen kutsuttavan <em>olion</em> luokkaan ja parametrien arvot. Käskyssä <em>invokevirtual</em> annetaan parametrina viite kutsuttavaan metodiin ja käskyn <em>invokevirtual</em> suorituksen jälkeen uusi kehys on valmis.</p><p>Esimerkki. Tarkastellaan metodia <em>A</em>, jossa on paikalliset muuttujat <em>x</em> ja <em>y</em>. Metodissa <em>A</em> on seuraavana Java-lausetta <em>y=Obj.B(x, 5)</em> vastaava tavukoodinen kutsu. Kutsun voisi toteuttaa vaikkapa seuraavalla tavalla.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Metodi A\n\n...\ngetstatic #35       0xb2 0x00 0x23   viite olion Obj luokkaan on CPP+35:ssä\niload  x            0x1b             parametri 1, muuttujan x arvo, osoite LV+1\nbipush 5            0x10 0x05        parametri 2, vakio 5\ninvokevirtual #37   0xb6 0x00 0x25   viite metodiin B on CPP+37:ssä</code></pre></div><!-- Kuva: ch-10-2-metodin-kutsu --><p><img src=\"/6d43951fd5820f5b0038e71f0e7ec5ad/ch-10-2-metodin-kutsu.svg\" alt=\"Vasemmalla on pinon alkutilanne ja oikealla pinon tila kutsun &#x22;invokevirtual B&#x22; jälkeen. Alkutilanteessa on metodin A kehys, jonka alkuun osoittaa LV. Metodin A kehyksesä on kentät &#x22;link pointer&#x22;, &#x22;parametri 1&#x22;, paikalliset muuttujat ml. x ja y, A:n kutsujan PC ja LV. Sen päällä on on kutsuttavan metodin B viite ja parametrit 1 ja 2.  Oikealla puolella metodin A kehyksen päälle on rakennettu metodin B kehys siten, että kutsuttavan metodin B viitteen paikalle on nyt laitettu linkki paluuosoitteeseen ja LV tähän linkkikenttään, joka on samalla metodin B kehyksen ensimmäinen sana. Metodin B kehyksen paikallisissa muuttujissa on myös muuttuja g.\"></p><div>\n<illustrations motive=\"ch-10-2-metodin-kutsu\" frombottom=\"0\" totalheight=\"40%\"></illustrations>\n</div><p>Esimerkissä käskyn <em>invokevirtual</em> jälkeen kutsutun metodin <em>B</em> kehys on valmis. Paluusoite löytyy epäsuorasti osoitteesta LV, parametrit ovat osoitteissa LV+1 ja LV+2, minkä jälkeen pinossa on paikalliset muuttujat. Pinon pinnalla on aikaisemman metodin <em>A</em> kehyksen osoite, mitä tarvitaan metodista <em>B</em> paluun yhteydessä.</p><p>Oletetaan nyt, että metodi <em>B</em> palauttaa arvonaan yhden kokonaisluvun, joka on ennen metodista paluukäskyä <em>ireturn</em> talletettu pinon pinnalle.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">metodi Obj.B\n\n...\niload  g          0x15  0x08  aseta paluuarvo paikallisesta muuttujasta g, osoite LV+8\nireturn           0xac        palauta paluuarvo ja kontrolli kutsuvaan rutiiniin</code></pre></div><!-- Kuva: ch-10-2-metodista-paluu --><p><img src=\"/d6d69fdb343c047f730b8340017a311f/ch-10-2-metodista-paluu.svg\" alt=\"Vasemmalla on pinon alkutilanne ja oikealla pinon tila käskyn &#x22;ireturn&#x22; jälkeen. Vasemmalla tila on täsmälleen sama kuin edellisen kuvan oikealla puolella. Oikealla puolella tila muuten sama, mutta kutsutun metodin parametrit ovat poissa ja metodin B viitteen asemesta siinä kohtaa on nyt metodin B paluuarvo.\"></p><div>\n<illustrations motive=\"ch-10-2-metodista-paluu\" frombottom=\"0\" totalheight=\"40%\"></illustrations>\n</div><p>Käskyn <em>ireturn</em> suorituksessa metodin <em>B</em> kehyksen tiedoilla palautetaan rekistereiden PC, LV ja SP arvot ennalleen ja kopioidaan paluuarvo pinon huipulle. Metodin <em>A</em> suoritus voi nyt jatkua ja ensimmäisenä se tietenkin ottaa paluuarvon talteen.</p><p>Metodin <em>B</em> käyttö on nyt kokonaisuudessaan seuraavanlainen.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">metodi A\n\n...\ngetstatic #35       0xb2 0x00 0x23   viite olion Obj luokkaan on CPP+35:ssä\niload  x            0x1b             parametri 1, muuttujan x arvo, osoite LV+1\nbipush 5            0x10 0x05        parametri 2, vakio 5\ninvokevirtual #37   0xb6 0x00 0x25   viite metodiin B on CPP+37:ssä\nistore y            0x36 0x04        paluuarvo pinosta muuttujaan y, osoite LV+4\n...</code></pre></div><h2>Tavukoodi</h2><p>Tarkoituksena ei ole tässä käydä kaikkia <a href=\"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\" target=\"_blank\" rel=\"noopener noreferrer\">tavukoodin käskyjä</a> läpi, vaan antaa yleiskuva niistä. Alla käydään kursorisesti läpi tavukoodin tietotyypit, tiedonosoitusmoodit ja erilaiset käskytyypit.</p><h3>Tietotyypit</h3><p>Käytössä on 1-, 2-, 4- ja 8-tavuiset kokonaisluvut. Datatyyppien nimet ovat vastaavasti <em>byte</em>, <em>short</em>, <em>int</em> ja <em>long</em>. Negatiiviset luvut esitetään kahden komplementin esitysmuodossa. Pieni 1-2 tavun data pakataan taulukoihin ja niihin viitataan taulukoissa omilla load- ja store-konekäskyillä. Pinossa ja vakioaltaassa kaikki data on kokonaisina sanoina.</p><p>Liukuluvut esitetään <a href=\"https://en.wikipedia.org/wiki/IEEE_floating_point\" target=\"_blank\" rel=\"noopener noreferrer\">IEEE liukulukustandardin</a> mukaisesti. Tavallinen liukuluku <em>float</em> on 4 tavua (32 bittiä) ja kaksoistarkkuuden liukuluku <em>double</em> on 8 tavua (64 bittiä).</p><p>Merkit esitetään käyttäen etumerkitöntä <a href=\"https://en.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"noopener noreferrer\">Unicode</a> merkistöä, jossa kukin merkki esitetään kahdella tavulla. Merkkijonot talletetaan kekoon ja niiden viitetiedot vakioaltaaseen. JVM:n merkkejä tai merkkijonoja ei käsitellä tämän enempää.</p><h3>Tiedonosoitusmoodi</h3><p>Tavukoodissa tiedonosoitus on välitöntä tai indeksoitua. Indeksoidut viitteet ovat suhteessa SP-, LV- tai CPP-rekistereihin, mutta rekisteri määräytyy implisiittisesti konekäskyyn mukaan.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iadd               0x60             implisiittiset dataviittaukset pinoon, osoitteet SP, SP-1\nbipush 5           0x10 0x05        viite vakioarvoon 5 (välitön operandi)\niconst_1           0x04             implisiittinen viite kokonaislukuvakioon 1\nfconst_1           0x0c             implisiittinen viite liukulukuvakioon 1.0\niload 6            0x15 0x06        viite dataan osoitteessa LV+6 (indeksoitu viite)\ninvokevirtual #37  0xb6 0x00 0x25   viite dataan osoitteessa CPP+37 (indeksoitu viite)</code></pre></div><p>Koodiin voi tehdä myös indeksoituja viitteitä suhteessa PC-rekisterin arvoon. Koodiviitteet ovat <em>tavuosoitteita</em>, koska käskyjen pituudet voivat 1-17 tavua (yleensä 1-3 tavua).</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">invokevirtual #37   0xb6 0x00 0x25   PC saa CPP+37:ssä olevan arvon (metodin osoitteen luokassa)\ngoto -27            0xa7 0x80 0x1B   PC saa arvon PC-27, ehdoton hyppy taaksepäin,\n                                     siirtymän määrä 16-bittisenä etumerkillisenä kokonaislukuna</code></pre></div><h3>Käskytyypit</h3><p>Käytössä on useita tietotyyppejä ja kussakin aritmeettis-loogisessa operaatiossa argumenttien täytyy olla saman kokoisia ja samaa tyyppiä. Tätä varten käskykannassa on useita datan tyypinmuunnoskäskyjä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i2b       0x91       muuta 32-bittinen kokonaisluku (word) 8-bittiseksi (byte). Etumerkki!\ni2f       0x86       muuta 32-bittinen kokonaisluku (word) 32-bittiseksi liukuluvuksi (float)\nd2l       0x8f       muuta 64-bittinen liukuluku (double) 64-bittiseksi kokonaisluvuksi (long)\nd2i       0x8e       muuta 64-bittinen liukuluku (double) 32-bittiseksi kokonaisluvuksi (int)</code></pre></div><p>Tiedonsiirtokäskyistä on jo esitelty käskyjä, joilla kopioidaan 32-bittinen kokonaisluku pinon pinnalle tai siirretään pinon pinnalla olevaa dataa muualle. Vastaavat käskyjä on eri pituisille data-alkioille ja tietotyypeille. Aritmeettis-loogisten lausekkeiden toteutuksissa pinon pinnalla olevaa dataa tarvitsee usein monistaa tai järjestää uuteen järjestykseen.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iload_2        0x1c            push (LV+2)     tuo kokonaisluku\nistore 17      0x36 0x11       pop  (LV+17)    vie kokonaisluku\nlload  12      0x16 0x0C       push (LV+12)    tuo pitkä kokonaisluku\nfload  10      0x17 0x0A       push (LV+10)    tuo liukuluku\ndstore 6       0x39 0x06       pop  (LV+6)     vie pitkä liukuluku\naload 3        0x2d 0x03       push (LV+3)     tuo viite (osoite)\ndup            0x59            push (SP)       monista data\ndup_x2         0x5b            push (SP-2)     monista data\ndup2           0x5c            push (SP)       monista pitkä data\nswap           0x5f            swap(SP, SP-1)  vaihda sanat\nbipush 5       0x10 0x05       push (5)        tuo kokonaislukuvakio\niconst_1       0x04            push 1          tuo kokonaislukuvakio\nfconst_1       0x0c            push 1.0        tuo liukulukuvakio\ngetstatic #35  0xb2 0x00 0x23  push (CPP+35)   tuo luokan viite</code></pre></div><p>Taulukkoviitteet ovat JVM:ssä yllättävän vaikeita. Taulukot talletetaan kekoon ja niiden viitetiedot vakioaltaaseen. Taulukoihin viitataan kehyksen muuttujista. Taulukkoviittauksessa pinoon tuodaan ensin taulukon viite (osoite vakioaltaassa) ja indeksi, minkä jälkeen vasta voidaan tehdä varsinainen viittaus taulukkoon. Esimerkiksi, Java-lauseen \"a=t[i];\" toteutus tavukoodilla voisi olla</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">aload_1         0x2b          push (LV+1)   taulukon viite t (parametrissa 1)\niload_2         0x1c          push (LV+2)   indeksi i (parametrissa 2)\niaload          0x2e          push (t[i])   korvaa t ja i alkion t[i] arvolla\nistore_3        0x3e          pop (LV+3)    taulukon kokonaislukuarvo (paikallinen muuttuja 1)</code></pre></div><p>Jos taulukko t sisältäisi neljän tavun kokonaislukujen asemesta yhden tavun kokonaislukuja, niin saman lauseen toteutus olisi</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">aload_1         0x2b          push (LV+1)   taulukon viite t\niload_2         0x1c          push (LV+2)   indeksi i\nbaload          0x33          push (t[i])   laajennna tavu samalla sanaksi\nistore_3        0x3e          pop (LV+3)    tallenna kokonaislukuarvo sanana</code></pre></div><p>Kontrollinsiirtokäskyjä on paljon, koska eri tietotyypeille tarvitaan kullekin omat ehdolliset haarautumiskäskynsä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">goto -27            0xa7 0x80 0x1B   PC saa arvon PC-27, ehdoton hyppy taaksepäin\nif_icmpgt  +33      0xa3 0x00 0x21   vertaa pinon arvoja. Jos isompi, niin PC saa arvo PC+33\nif_icmpeq  -27      0x9f 0x80 0x1B   vertaa pinosn arvoja. Jos sama, niin PC saa arvo PC-27\niflt  +33           0x9b 0x00 0x21   jos pinossa oleva arvo &lt;0, niin PC saa arvon PC+33\nlcmp                0x94             vertaa kahta pitkää kokonaislukua, tulos pinoon (+1, 0, -1)\nfcmpg               0x96             vertaa kahta liukulukua, tulos pinoon (+1, 0, -1)\ninvokevirtual #37   0xb6 0x00 0x25   call (CPP+37)\nireturn             0xac             palaa kutsutusta metodista</code></pre></div><p>Aritmeettis-loogisia operaatioita on vastaavasti useita, koska yhden tai kahden sanan pituusvaihtoehdoille tarvitaan omat käskynsä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iadd      0x60     kokonaislukujen (int) yhteenlasku\niand      0x7e     and-operaatio pareittain 32-bittisille loogisille arvoille kokonaisluvuissa\ndmul      0x63     64-bittisten liukulukujen yhteenlasku\nldiv      0x6d     64-bittisten kokonaislukujen jakolasku\nlrem      0x71     64-bittisten kokonaislukujen jakolaskun jakojäännös</code></pre></div><p>Lisäksi tavukoodiin sisältyy sekalainen joukko muita käskyjä, joista alla on muutamia esimerkkejä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">nop             0x00               no operation, kuluttaa vähän aikaa\npop             0x57               ota sana pinosta, heitä pois\narraylength     0xbe               pinon päällä viitatun taulukon pituus\nathrow          0xbf               aiheuta keskeytys\nnew  House      0xbb  0x00 0x03    luo uusi House-tyyppinen olio (instanssi)</code></pre></div><h2>Esimerkki tavukoodin käytöstä</h2><p>Tarkastellaan Java-kielistä koodinpätkää</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">k = i+5;\n\nif (k=10)\n    j=i;\nelse\n    j=k;</code></pre></div><p>Kokonaislukuarvoiset muuttujat <em>i</em>, <em>j</em> ja <em>k</em> ovat paikallisia muuttujia kehyksen osoitteissa 7, 8 ja 9. Jos tavukoodinen koodinpätkä alkaa tavusta 100 (desimaaliluku), niin tästä voisi generoitua tavukoodi</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tavukoodi tekstinä       heksadesimaalina\n\nstrt  iload i            100:   0x15 0x07\n      bipush 5           102:   0x10 0x05\n      iadd               104:   0x60\n      dup                105:   0x59             k tarvitaan kohta taas\n      istore k           106:   0x36 0x09\n\n      bipush 10          108:   0x10 0x0A        k oli pinossa jo\n      if_icmpeq else     110:   0x0f 0x00 0x0A   110+10=120\nif10  iload i            113:   0x15 0x07\n      istore j           115:   0x36 0x08\n      goto done          117:   0xa7 0x00 0x07   117+7=124\nelse  iload k            120:   0x15 0x09\n      istore j           122:   0x36 0x08\ndone  nop                124:   0x00</code></pre></div><p>Tavun 105 käsky <em>dup</em> käyttö on jo vähän koodin optimointia. Lisäoptimoinnilla koodi voisi ehkä olla vielä tehokkaampi. Esimerkiksi,  <em>istore j</em> käskyt voisi yhdistää haarautumisen jälkeen tehtäväksi. Tällöin koodista tulisi kolme tavua lyhyempi, kun nop-käskyäkään ei enää tarvittaisi vain haarautumisen loppuosoitetta varten.</p></div>","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}},"allPages":{"edges":[{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}