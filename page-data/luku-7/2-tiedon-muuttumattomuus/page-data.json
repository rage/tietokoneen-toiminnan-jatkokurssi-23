{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-7/2-tiedon-muuttumattomuus","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Tässä osiossa tarkastelemme perusmenetelmiä, joilla voidaan valvoa tiedon muuttumattomuutta tietokonejärjestelmissä. Järjestelmään tallennettu tai siellä siirrettävä tieto voi muuttua esimerkiksi laitteistovian, satunnaisen avaruudesta tulleen hiukkasen tai tahallisen tietoturvahyökkäyksen vuoksi. Syystä tai toisesta, järjestelmässä oleva tieto on muuttunut virheelliseksi. Haluaisimme havaita kaikki tällaiset virheet ja mahdollisuuksien mukaan myös korjata ne."}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tiedon muuttumattomuuden turvaamisen pääperiaatteet"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lähtökohta riittävän hyvän tiedon muuttumattomuuden takaamiselle on hyväksyä se, että virheitä tapahtuu. Perusidea virheiden havaitsemiselle on ottaa mukaan ylimääräisiä bittejä, joiden avulla virhe voidaan havaita ja ehkä jopa korjata. Käytännössä tämä tarkoittaa sitä, että rekistereihin ja muistipiireihin laitetaan ylimääräisiä bittejä ja tiedonsiirtoväyliin ylimääräisiä johtimia. Näiden lisäksi virheen havaitseva koodi pitää myöskin toteuttaa ja sen voi tehdä joko suoraan laitteistolla tai erillisillä suoritettavilla ohjelmilla. Jos ajatellaan esimerkiksi muistiväylän suojaamista, niin nopeusvaatimusten vuoksi kaikki tarkistukset tulee tehdä laitteistototeutuksina."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ylimääräiset bitit ja johtimet vaativat ylimääräistä tilaa ja tarkistusten tekeminen vaatii aikaa. Tiedon muuttumattomuuden suojaamisen kustannus maksetaan siten sekä tilassa että ajassa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Se, paljonko olemme valmiita maksamaan järjestelmässä olevan tiedon muuttumattomuudesta, riippuu järjestelmästä. Esimerkiksi kotikoneessa on usein tavallista muistia eikä virheen korjaavaa ("},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/ECC_memory","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"ECC-muistia"}]},{"type":"text","value":"), koska tavallinen muisti on halvempaa. Lääketieteellisen sädehoitolaitteen muisti taas on ainakin yhden virheen havaitsevaa ja korjaavaa muistia, koska kukaan ei halua virheellistä määrää säteilyä satunnaisen avaruushiukkasen vuoksi."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tiedon muuttumattomuuden turvausmenetelmien ominaisuudet"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Luokittelemme tiedon muuttumattomuuden turvausmenetelmiä useiden ominaisuuksien perusteella. Yleensä kuhunkin käyttöön sopivan menetelmän valinta tapahtuu usean ominaisuuden yhdistelmänä, ottaen huomioon riskien hallinta hyväksytyllä tasolla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kuinka monen bitin muuttuminen havaitaan? Menetelmä, joka havaitsee kahden bitin muuttumisen, on parempi kuin sellainen, joka havaitsee vain yhden bitin muuttumisen, mutta se on myös kalliimpi toteuttaa. Esimerkiksi, jos virheet ovat satunnaisia ja yhden virheen esiintymistodennäköisyys on P(virhe) = 1:1 000 000, niin kahden virheen yhtä aikaa tapahtumisen todennäköisyys on sama kuin yhden virheen todennäköisyys potenssiin 2 eli P(2 virhettä) = (P(virhe))"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":" = 1:1 000 000 000 000. Pienlentokoneen järjestelmän suunnittelijat voivat hyvin päättää, että riittää varautua yhteen virheeseen kerrallaan, koska kahden samanaikaisen virheen todennäköisyys on niin pieni. Toisaalta, jos kyseessä on suuri matkustajalentokone, niin olisiko parempi varautua myös kahteen samanaikaiseen virheeseen?"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kuinka monta viallista bittiä voidaan korjata? Joissakin tapauksissa riittää, että virhe havaitaan ja raportoidaan, jonka jälkeen jokin ulkopuolinen taho korjaa tilanteen. Esimerkiksi verkkoliikenteessä on tyypillistä, että tietoliikennepaketteja katoaa tai menee rikki matkalla. Jos paketissa on viallisia bittejä, niin niitä on helposti niin monta, että niiden korjaaminen ei kuitenkaan onnistu. On helpompi pyytää lähettäjää lähettämään kyseinen paketti uudelleen ja toivoa parasta. Toisaalta, jos muistipiiri on ECC-tyyppinen, niin sitä voi hyvin käyttää ainakin vähän aikaa, vaikka jokin bitti olisikin rikki. Rikkinäisen bitin tieto voidaan lennossa laskea ylimääräisten virheen korjaavien bittien avulla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Mikä on virheen kustannus muistitilan tai piirin pinta-alan suhteen? Tämä tarkoittaa yksinkertaisesti sitä, että kuinka paljon ylimääräisiä bittejä tai johtimia tarvitaan (esimerkiksi) 64-bittistä sanaa kohden. Johtimien vetäminen mikropiirin pinnalla voi viedä yllättävän paljon arvokasta pinta-alaa, jolle voisi löytyä muutakin käyttöä - esimerkiksi isompana välimuistina."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Mikä on virheen kustannus ajassa ja tehdäänkö virheiden havaitsemis/korjauslaskelmat laitteistolla vai ohjelmistolla? Tarkistuskoodin suorittamismenetelmä määräytyy yleensä suoraan siitä, minkä tason tiedosta on kyse. Suorittimen sisäisen väylän tai muistiväylän tiedonsiirron turvaaminen täytyy tapahtua laitteistototeutuksena, koska tarkistus pitää tehdä huomattavasti nopeammin kuin yhden konekäskyn suoritusajassa. Massamuistin, tietoliikenteen ja pilvipalvelimien tiedon tarkistus voidaan hyvin tehdä ohjelmallisesti, koska niiden käyttö on joka tapauksessa hidasta."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkinä tiedot muuttamattomuuden tarkistamisesta voidaan käyttää "},{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Henkil%C3%B6tunnus","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"henkilötunnusta"}]},{"type":"text","value":", vaikka tietoa siinä käsitelläänkin merkkikohtaisesti eikä bitteinä. Henkilötunnus on muotoa 120364-121K, jossa alkuosa \"120364\" on syntymäaika ilman vuosisataa, välimerkki ´-´ ilmaisee syntymäajan vuosisadan 1900-luku ('+' on 1800-luku ja 'A' on 2000-luku), \"121\" ilmaisee parittomana lukuna sukupuoleksi miehen ja muutoin uniikin arkistointinumeron tälle henkilölle. Viimeinen merkki ´K´ on tarkistusmerkki, jonka arvo saadaan jakamalla edellä oleva 9-numeroinen luku 120364121 luvulla 31 ja koodaamalla jakojäännös sopivasti. Merkki ´K´ kertoo, että jakojäännös on 18. Matemaattisesti voidaan osoittaa, että tämän tarkistusmerkin avulla löydetään ainakin kaikki yhden merkin virheet ja kaikki kahden merkit vaihtumiset. Rakenteellisena puutteena järjestelmässä on, että välimerkin muuttumattomuutta ei valvota lainkaan. Tämän vuoksi kaikkien käytössä olevien henkilötunnusten on pakko erota toisistaan myös muutoin kuin välimerkin osalta. Tästä taas on seurauksena arkistointinumeroiden loppuminen piakkoin, joten uuden henkilötunnuksen käyttöönotolla alkaa olla kiire. Henkilötunnuksessa havaitaan yhden merkin muuttuminen (ei välimerkissä), mutta virhettä ei voi paikallistaa eikä korjata. Tarkistusmerkin tilakustannus on 9%, koska 11 merkistä yksi on tarkistusmerkki. Tarkistus vaatii jonkin verran laskentaa ja tehdään aina ohjelmallisesti."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toinen esimerkki tarkistusmerkeistä on Suomessa käytetty "},{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/IBAN","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"IBAN"}]},{"type":"text","value":" tilinumero. Siinä olevien kahden tarkistusmerkin (numeron) avulla havaitaan kaikki yhden merkin virheet ja useimmat kahden merkin virheet. Kaikki kahden merkin vaihtumiset huomataan samoin kuin useimmat muutkin virheet. Virheitä ei voi korjata lainkaan."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"500015-123                  vanhan muotoinen pankkitilin numero\n5000 1500 0001 23           laajenna pankkiosa 14-numeroiseksi\n5000 1500 0001 23 FI00      lisää loppuun FI00\n5000 1500 0001 23 15 18 00                  muuta  F=\"15\", I=\"18\"\n5000 1500 0001 23 15 18 00 mod 97 = 61      laske modulo 97\n5000 1500 0001 23 FI37      laske 98-61=37 ja aseta 37 FI-merkkien jälkeen\nFI37 5000 1500 0001 23      Siirrä FI-osa alkuun, uusi IBAN-numero"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tarkistusmerkkien kustannus on 2 merkkiä 18:sta eli yli 10%. Tarkistusmerkkien oikeellisuuden laskenta tehdään ohjelmallisesti."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Pariteettibitti"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bittitasolla yksinkertaisin ja yleinen tarkistusmenetelmä on pariteettibitti. Se on ylimääräinen bitti, jonka avulla tiedon 1-bittien lukumäärästä tehdään parillinen tai pariton. Käytössä sanotaan tuolloin olevan joko "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"parillinen"}]},{"type":"text","value":" tai "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pariton pariteetti"}]},{"type":"text","value":". Esimerkiksi, 32-bittisessä sanassa voidaan varata 31 bittiä datalle ja 1 bitti pariteettibitille. Tietoa talletettaessa pariteettibitin arvo lasketaan ja talletetaan paikalleen. Joka kerta tietoa luettaessa tarkistetaan, että pariteetti on oikein. Jos se ei ole, niin virhe käsitellään esimerkiksi kutsumalla jotain aliohjelmaa tai aiheuttamalla sopiva keskeytys."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki 15-bittisen datan suojaamisesta parillisella pariteettibitillä,\nkun tietoalkio on 16-bittinen. Pariteettibitti on oikeanpuoleisin bitti\neli bitti numero 0.\n\n0111 0001 1110 0100   - pariteettibitti on 0\n1010 1111 0010 1101   - pariteettibitti on 1"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pariteettibitin kustannus tietoalkiota kohden on 1 bitti, joten suuremmilla tietoalkioilla sen suhteellinen osuus on pienempi.\nPariteettibitin avulla voidaan havaita kaikki yhden bitin virheet, mutta kaikki kahden bitin virheet jäävät havaitsematta."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0111 0001 1110 0000   - bitti nro 2 muuttunut, virheellinen pariteetti\n1010 1111 0010 1011   - bitit nro 2 ja 3 muuttuneet, oikea pariteetti"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pariteettibitin avulla ei voida mitenkään paikallistaa virhettä, joten virheen mahdollinen korjaus täytyy tehdä ylemmällä tasolla ohjelmistoa jollain muulla tavalla. Pariteettibitti kuitenkin sopii hyvin tilanteisiin, joissa yhden bitin virhe on aika pieni, mutta kahden bitin samanaikainen vikaantuminen on hyvin epätodennäköistä. Tällaisissa tilanteissa kolmen bitin yhtäaikaisen vikaantumisen todennäköisyys on vielä paljon pienempi."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"P(1 bitin virhe) = 1:1000 000                 = 1E-6\nP(2 bitin virhe) = 1:1000 000 000 000         = 1E-12\nP(3 bitin virhe) = 1:1000 000 000 000 000 000 = 1E-18"}]}]}]},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Richard Hamming"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Richard_Hamming","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Richard Hamming"}]},{"type":"text","value":" oli tietojenkäsittelytieteen pioneereja. Ennen tietojenkäsittelyyn liittyvää uraansa hän mm. osallistui Manhattan-projektissa atomipommin kehitystyöhön. Vuonna 1945 hän mm. tarkasti laskelmia siitä, tuhoaisiko atomipommi maapallon koko ilmakehän vai ei. Laskelmat oli tehty oikein, mutta hän ollut varma kaikkien oletusten paikkansapitävyydestä. Sodan jälkeen Hamming siirtyi "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Bell_Labs","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Bell Labs"}]},{"type":"text","value":"'ille ja työskenteli osan aikaa samassa työhuoneessa informaatiotieteen isäksi kutsutun "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Claude_Shannon","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Claude Shannonin"}]},{"type":"text","value":" kanssa."}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Hamming-etäisyys"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Richard Hamming tutki 1950-luvulla koodatun tiedon muuttumattomuutta eri koodijärjestelmissä. "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Hamming_distance","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Hamming-etäisyys"}]},{"type":"text","value":" on niiden bittien lukumäärän jonka mukaisen määrän bittejä täytyy muuttua, jotta jokin laillinen merkki muuttuu toiseksi saman koodijärjestelmän toiseksi lailliseksi merkiksi. Mitä isompi Hamming-etäisyys tietyssä koodausjärjestelmässä on, sitä parempi. Jos virheitä (bittien muuttumisia) tapahtuu vähemmän kuin Hamming-etäisyyden verran, niin tuloksena on aina virheelliseksi havaittavissa oleva tietoalkio."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"7-bittinen ASCII-merkistö\n\n'A' = 0x41 =  100 0001\n'B' = 0x42 =  100 0010   Hamming-etäisyys (A,B) = 2\n'C' = 0x43 =  100 0011   Hamming-etäisyys (B,C) = 1"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koodijärjestelmän Hamming-etäisyys on pienin Hamming-etäisyys kyseisen järjestelmän merkkien välillä. Edellisen esimerkin ASCII-koodiston Hamming-etäisyys on siten yksi. Tämä tarkoittaa, että yhden bitin virheitä ei voi havaita. Esimerkiksi, merkin 'B' viimeisen bitti muuttuminen nollasta ykköseksi muuttaa sen merkiksi 'C', eikä virhe ole mitenkään havaittavissa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos 7-bittiseen ASCII-koodistoon lisätään pariteetti-bitti, niin koodijärjestelmän Hamming-etäisyys kasvaa kahteen. Nyt kaikki yhden bitin virheet havaitaan ja järjestelmä on paljon turvallisempi. Jos merkin 'B' bitti 0 muuttuu nyt ykkösestä nollaksi, niin virhe havaittaisiin nyt siitä, että pariteettibitti on väärin."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"7-bittinen ASCII-merkistö + pariteettibitti (bitti 7)\nParillinen pariteetti\n\n'A' = 0x41 = 0100 0001\n'B' = 0x42 = 0100 0010   Hamming-etäisyys (A,B) = 2\n'C' = 0xC3 = 1100 0011   Hamming-etäisyys (B,C) = 2\nmuuttunut 'B' = 0100 0011   virheellinen data, pariteetti on väärin"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pariteeettibitin kanssa kyseessä ei ole enää sama koodijärjestelmä. Esimerkiksi 'C' on ASCII-koodissa 0x43, kun se uudessa koodausjärjestelmässä olisi 0xC3."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Hamming-koodi"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Hamming_code","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Hamming-koodissa"}]},{"type":"text","value":" data-bittien joukkoon lisätään useita pariteetti-bittejä, joiden avulla yhden bitin virheet voidaan paikallistaa ja sen jälkeen korjata.  Esimerkiksi nyt myytävissä virheenkorjaavissa ECC-muistipiireissä virheenkorjaus useimmiten edelleen perustuu Hamming-koodiin, vaikka myös muita menetelmiä on käytössä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodin perusidea on järjestää data-bitit erilaisiin joukkoihin (pariteettijoukkoihin) sillä tavoin, että jokainen databitti kuuluu uniikkiin joukkoon näitä ryhmiä. Jokaisella pariteettijoukolla on sitten oma pariteettibittinsä. Jos joku bitti muuttuu, niin virheellisen bitin sijainti voidaan päätellä virheellisistä pariteettibiteistä. Tarkemmin sanoen, virhe paikallistetaan niistä pariteettijoukoista, joihin virheellinen bitti kuuluu."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Hamming(7,4) esimerkki"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Hamming(7,4)","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Hamming(7,4)"}]},{"type":"text","value":" esimerkki kuvaa hyvin Hamming-koodin periaatteen. Siinä seitsemästä tietoalkion bitistä neljä on data-bittejä ja niitä vartioi kolme pariteettibittiä."}]},{"type":"comment","value":" kuva: ch-7-2-Hamming-7-4  "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/6b394d4d11603bab898c183c472e73b7/ch-7-2-Hamming-7-4.svg","alt":"Hamming(7,4) esimerkki, jossa 7 tietobitistä 4 kappaletta on databittejä ja 3 pariteettibittejä. Kuvassa on neljä osaa: (a), (b), (c) ja (d). Osassa (a) on databitit a, b, c ja d, joiden arvot ovat a=0, b=1, c=1 ja d=0. Bitti b on keskellä, bitti a on bitin b vasemmalla puolella, bitti c on bitin b yläpuolella oikealla ja bitti d on bitin b alapuolella oikealla. Bitit a, b ja c kuuluvat (pariteetti) joukkoon A. Bitit a, b ja d kuuluvat joukkoon B. Bitit b, c ja d kuuluvat joukkoon C. Osassa (b) ovat myös joukkojen parilliset pariteettibitit mukana: A=0, B=1 ja C=0. Joukot on piirretty ympyröinä, joihon kuuluvat kunkin joukon data- ja pariteettibitit. Osassa (c) alhaalla oikealla oleva databitti d on vaihtunut virheelliseen arvoon 1, jolloin joukkojen B ja C pariteettibitit B=1 ja C=0 ovat väärin. Osassa (d) databitti d on korjattu oikeaksi arvoon 0 ja kaikki pariteettibitit ovat taas oikein."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-7-2-Hamming-7-4"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lähtötilanteessa (a) on merkittynä databittien arvot ja pariteettijoukot (A, B ja C). Huomaa, että jokainen databitti kuuluu uniikkiin ryhmään pariteettijoukkoja. Esimerkiksi vasemmanpuolimmainen databitti kuuluu joukkoihin A ja B, mutta ei joukkoon C. Tällainen joukkoihin kuuluminen ei päde millekään muulle bitille."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jokaiselle joukolle on oma pariteettibittinsä. Tilanne (b) näyttää kunkin pariteettibitin arvon, parillista pariteettia käyttäen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ajatellaan nyt, että yksi data-biteistä (oikealla alhaalla oleva) muuttuu syystä tai toisesta virheelliseksi, jolloin tilanne on kohdan (c) mukainen. Kyseinen databitti kuuluu joukkoihin B ja C, joten niiden pariteettibitit ovat nyt virheellisiä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Virheen korjaus tapahtuu useassa vaiheessa. Ensinnäkin, jokin pariteettibiteistä on väärin, mikä indikoi jonkinlaista virhettä jossain. Seuraavaksi havaitaan virheen olevan joukoissa B ja C, mutta ei joukossa A. Vain yksi bitti täyttää nämä ehdot, joten virheellisen bitin täytyy olla oikealla alhaalla oleva databitti. Lopuksi virheellinen bitti "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"käännetään"}]},{"type":"text","value":" (flipataan) kohdan (d) mukaisesti toisin päin, jolloin sen arvo tulee korjatuksi. Binäärijärjestelmä on tässä tosi kätevä, kun virheelliselle binääriarvolle on vain yksi oikea vaihtoehto. Jos desimaalinumeron tiedettäisiin olevan väärin, niin silti olisi jäljellä yhdeksän muuta vaihtoehtoa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Entäpä jo virhe onkin pariteettibitissä eikä databitissä? Ei huolta, Hamming-koodi toimii myös siinä tapauksessa. Esimerkiksi, jos joukon A pariteettibitti (0) vaihtuu ykköseksi, niin silloin joukon A pariteettibitti on väärin ja muiden joukkojen pariteettibitit ovat oikein. Ainoa bitti, joka kuuluu joukkoon A mutta ei joukkoihin B tai C, on joukon A pariteettibitti. Virhe on näin paikallistettu ja voidaan korjata. Tilanne on vähän samanlainen kuin jonkin varoitusvalon rikkoutuminen autossa. Itse auton toiminnoissa ei ole mitään ongelmaa, mutta turvajärjestelmän toimivuuden vuoksi vika pitää silti korjata."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkin Hamming-koodin kustannus on aika korkea. Lähes puolet (3/7 = 43%) biteistä ovat pariteettibittejä. Lisäksi vaatii aika paljon laskenta-aikaa asettaa pariteettibitit paikalleen ja tarkistaa niiden oikeellisuus. Todellisuudessa käytettävä Hamming-koodi on yksinkertaisuudessaan vielä nerokkaampi ja "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Scalability","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"skaalautuu"}]},{"type":"text","value":" hyvin myös suurempien data-alkioden virheenkorjaukseen. Virheellisen bitin sijainnin päättely tapahtuu yksinkertaisen yhteenlaskun avulla."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Virheen korjaava Hamming-koodi"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodissa pariteettijoukot määritellään ovelasti ja joukot voivat ovat erikokoisia. Ensinnäkin on huomattava, että bitit numeroidaan (esimerkiksi) oikealta päin alkaen ykkösestä (ei nollasta, kuten yleensä bittien numeroinnin kanssa on). Seuraavaksi tarkastellaan bitin numeron binääriesitystä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Tietoalkio (7 bittiä):     100 1100\nBitin numero:              765 4321\n\nBitin      Bitin numeron\nnumero     binääriesitys\n\n  1          001\n  2          010\n  3          011\n  4          100\n  5          101\n  6          110\n  7          111\n  ...        ..."}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kukin tietoalkion bitti kuuluu joukkoon "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"2^(i-1)"}]},{"type":"text","value":", jos bitin numeron binääriesityksessä i:nnes bitti oikealta on 1. Äskeisessä esimerkissä joukkoon 1 kuuluvat siten bitit 1, 3, 5 ja 7. Joukkoon 2 kuuluvat bitit 2, 3, 6 ja 7. Joukkoon 4 kuuluvat bitit 4, 5, 6 ja 7."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toisin päin katsottuna, se, mihin joukkoihin kukin bitti kuuluu, näkyy suoraan bitin numeroesityksestä. Bitti 1 kuuluu joukkoon 1, mutta ei joukkoihin 2 tai 4. Bitti 3 kuuluu joukkoihin 1 ja 2, mutta ei joukkoon 4. Bitti 7 kuuluu kaikkiin joukkoihin 1, 2 ja 4. Jokainen bitti kuuluu erilaiseen ryhmään joukkoja, koska kunkin bitin numeron binääriesitys on uniikki."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lopuksi määritellään, että kaikki bitit, joiden numero on kakkosen potenssi, ovat pariteettibittejä. Näin jokaiseen joukkoon saadaan täsmälleen yksi pariteettibitti."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkiksi, 7-bittisellä tietoalkiolla bitit 1, 2 ja 4 ovat pariteettibittejä, jotka määrittelevät kukin oman pariteettijoukkonsa. Joukot nimetään sen pariteettibitin numeron perusteella. Täten bitti 1 on joukon 1 pariteettibitti, bitti 2 joukon 2 pariteettibitti, jne. Vastaavasti 136-bittisellä tietoalkiolla bitit 1, 2, 4, 8, 16, 32, 64 ja 128 ovat pariteettibittejä. 136-bittisellä tietoalkiolla on näin 128 data-bittiä ja 8 pariteettibittiä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos tarvitsemme 32 databittiä, niin niitä turvaamaan tarvitaan 6 pariteettibittiä (bitit 1, 2, 4, 8, 16 ja 32). Tietoalkiossa pariteettibitit ovat databittien välissä omilla paikoillaan. Yhteensä tarvitaan siis 38 bittiä. Tietoa käsitellessä tietoalkiosta käytetään vain databittejä, mutta tiedon muuttumattomuutta varmistettaessa käytetään kaikkia bittejä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Yhden virheellisen bitin paikallistaminen tapahtuu vastaavasti kuten aikaisemmin esitettiin. Käytämme tässä esimerkkinä 7-bittistä tietoalkiota 100 1100, jossa on neljän bitin data 1001 (bitit 3, 5, 6 ja 7) ja kolme pariteettibittiä (bitit 1, 2 ja 4). Käytössä on parillinen pariteetti."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"                Alkuperäinen  Virheellinen  Korjattu\n\nTietoalkio:        100 1100    110 1100     100 1100\nBitin numero:      765 4321    765 4321     765 4321\nPariteettivirhe:                   1 1"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkissä bitti numero 6 on kääntynyt virheelliseksi. Bitti 6 kuuluu joukkoihin 2 ja 4, joten pariteettibitit 2 ja 4 ovat nyt väärin. Virheen olemassaolo havaitaan jälleen siitä, että jokin pariteettibitti on väärin. Virhe paikallistetaan yksinkertaisesti laskemalla yhteen virheen indikoivien pariteettibittien numerot, eli tässä tapauksessa 2+4=6. Virhe korjataan kääntämällä bitti 6. Lopuksi tarkistetaan vielä, että kaikki pariteettibitit ovat nyt oikein. Jos ne eivät ole, niin virheitä oli useampi ja peli on menetetty."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Entäpä, jos virhe onkin vain pariteettibitissä? Se ei haittaa, sillä pariteettibitti sisältyy vain yhteen (omaan) pariteettijoukkoon ja virheellisen bitin sijainti identifioituu aivan oikein."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Useamman bitin virheitä ei välttämättä havaita alkuaankaan. Esimerkiksi, jos edellisen esimerkin tietoalkiossa 100 1100 kaksi bittiä (bitit 1 ja 6) kääntyvät virheellisiksi (tietoalkioksi 110 1101), niin kaikki pariteettibitit ovat väärin. Sen mukaisesti virheelliseksi bitiksi lasketaan 1+2+4=7 eli bitti 7 on muka virheellinen. Kun se käännetään vielä ympäri, saadaan tietoalkioksi 010 1101. Siinä ei ole pariteettivirheitä, mutta sen sijaan 3 virheellistä bittiä. Aina ei voi voittaa!"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"                Alkuperäinen   Virheellinen   Korjattu\n                 0 virhettä     2 virhettä    3 virhettä\n\nTietoalkio:      100 1100       110 1101        010 1101\nBitin numero:    765 4321       765 4321        765 4321\nPariteettivirhe:                    1 11"}]}]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"Hamming-koodin tilakustannus on sitä pienempi, mitä suuremmasta tietoalkiosta on kyse, koska vain kakkosen potenssin numeroiset bitit (eli muotoa 2"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"k"}]},{"type":"text","value":", k = 0, 1, 2, ...) ovat pariteettibittejä. Esimerkiksi, 1024 databitin turvaamiseen tarvitaan vain 11 ylimääräistä pariteettibittiä järjestysnumeroiltaan 2"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"text","value":", 2"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":", 2"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":", ..., 2"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"10"}]},{"type":"text","value":" = 1, 2, 4, ..., 1024."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodin aikakustannus vaihtelee sen mukaan, toteutetaanko tiedon muuttumattomuuden tarkistus laitteistolla vai ohjelmistolla. Jos Hamming-koodia käytetään muistipiirin tai väylän suojaamiseen, niin toteutus täytyy tehdä laitteistolla, koska toteutuksen täytyy olla paljon nopeampi kuin yhden konekäskyn suoritusaika. Esimerkiksi ECC-muistipiiriä käytettäessä muistipiiri laskee ja sijoittaa pariteettibitit paikalleen jokaisen muistiinkirjoituksen yhdessä. Vastaavasti muistia luettaessa muistipiiri tarkistaa luetun tiedon muuttumattomuuden suoraan laitteistolla, ennen kuin se antaa tiedon väylää pitkin eteenpäin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laitteistototeutuksessa ei virheen ilmetessä tarvita edes yhteenlaskua. Riittää, kun virheellisten pariteettibittien sijainnit laitetaan paikalleen johonkin sisäiseen rekisteriin ja tulos "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"tulkitaan"}]},{"type":"text","value":" kokonaisluvuksi!"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"                          Virheellinen data\n                              1 virhe\n\nTietoalkio:                   110 1100\nBitin numero:                 765 4321\nVirheelliset pariteettibitit:     1 1\nVirheen sijainti:             000 1010  = 6"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodin voi toteuttaa myös ohjelmistolla, jolloin se vaatii jonkin verran konekäskyjä bittimanipulaatioiden toteuttamiseksi. Se on työlästä puuhaa, mutta ei kovin monimutkaista."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käytännössä pelkkä virheen paikallistaminen ja korjaaminen ei tietenkään riitä. Se on vain tilapäinen lääke havaittuun virhetilanteeseen. Virheistä täytyy pitää kirjaa. Jos virhe toistuu saman muistipiirin kohdalla usein, niin ilmeisesti muistipiirissä on vika, joka pitää korjata jollain tavoin. Useimmiten se tarkoittaa muistipiirin vaihtamista uuteen. Jos vika on muistiväylässä, sen korjaaminen on vielä hankalampaa ja voi vaatia koko laitteiston uusimisen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodista on useita laajennuksia. Esimerkiksi lisäämällä pariteettibitti 0 voidaan havaita kaikki kahden bitin virheet, mutta niitä ei voi korjata. Lisäämällä vielä enemmän pariteettibittejä pystytään korjaamaan myös kaikki kahden bitin virheet, jne. Sopiva tiedon muuttumattomuuden suojaustaso määritellään tapauskohtaisesti sen mukaan, kuinka todennäköisiä virheet ovat ja kuinka suuret kustannukset havaitsemattomista (tai ei-korjattavissa olevista) virheistä aiheutuu."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Mitä lähempänä suoritinta ollaan, sitä tärkeämmäksi tulee suojautuminen (satunnaisilta) virheiltä. Suorittimen sisäisissä rekistereissä oleva ja väylillä liikkuva tieto on tärkeätä suojata muutoksilta. Kotikoneiden keskusmuisti voi usein olla suojaamatonta, mutta ainakin palvelinkoneiden muisti on yleensä ECC-muistia. ECC-muisti ei riitä, ellei myös muistiväylä ole virheiltä suojattu. Muistipiirit voi vaihtaa halutessaan kalliimpiin ECC-muisteihin. Väylää ei voi vaihtaa., koska se on kiinteä osa järjestelmää. Tämän vuoksi väylä on yleensä valmiiksi suojattu Hamming-koodilla."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tiedon muuttumattomuus tietoliikenteessä"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hamming-koodi ei sovi tiedon muuttumattomuuden havaitsemiseen sellaisessa tapauksessa, jossa muuttuneiden bittien määrä on todennäköisesti suurempi. Esimerkiksi tietoliikenteessä on tyypillistä, että jos virheitä tulee, niin sitten niitä tulee paljon. Virheiden korjaaminen on siten yleensä käytännössä mahdotonta tai sitten sen kustannus ylimääräisten bittien osalta aivan liian suuri."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käytännössä tietoliikenteessä riittää, kun tiedon muuttuminen havaitaan jollain tavoin. Sen jälkeen joko pyydetään lähettäjää lähettämään viallinen tietoliikennepaketti uudelleen tai vain jätetään kuittaamatta viallinen paketti. Jälkimmäisessä tapauksessa lähettäjä vähän ajan päästä arvelee paketin kadonneen matkalla ja lähettää sen uudelleen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tietoliikennepakettien tiedon muuttumattomuutta suojataan tarkistussummien avulla. Yksinkertainen tapa on tulkita kaikki paketin (esim. 4KB tai 4MB) sanat kokonaisluvuiksi ja laskea niiden summa. Summa voi olla kovinkin suuri (esim. 0x1234567890AB), mutta otetaan talteen siitä vain esimerkiksi 32 viimeistä bittiä tarkistussummaksi (0x567890AB). Tarkistussumma lähetetään paketin databittien mukana vastaanottajalle. Vastaanottaja laskee tarkistussumman uudestaan itse ja vertailee sitä saamaansa. Jos ne ovat erilaisia, jotain on muuttunut matkalla. On hyvin epätodennäköistä, että tarkistussumma olisi oikein satunnaisten virheiden jälkeen. Se on tietenkin mahdollista, mutta silti epätodennäköistä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edellä mainittua yksinkertaiseen "},{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Modulaarinen_aritmetiikka","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"modulo-aritmetiikkaan"}]},{"type":"text","value":" perustuvan tarkistussumman asemesta käytetään parempia matemaattisesti hyväksi havaittuja tarkistussummia. Niillä on mahdollista myös suojautua tahallista tiedon muuttumattomuuteen kohdistuvaa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"hyökkäystä"}]},{"type":"text","value":" vastaan, koska tarkistussumman väärentäminen on matemaattisesti vaikeata."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Yleisesti käytössä oleva tietoliikenteen tarkistussummamenetelmä on Wesley Petersonin 1961 kehittämä  "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Cyclic_redundancy_check","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Cyclic Redundancy Check"}]},{"type":"text","value":" (CRC), jossa tarkistussumma on esimerkiksi 32-bittinen. CRC:stä on useampi variantti eri käyttötarkoituksiin. Esimerkiksi, 16-bittinen variantti CRC-CCIIT löytää (i) kaikki yhden, kahden ja kolmen bitin virheet, (ii) kaikki virheet, joissa virheellisten bittien lukumäärä on pariton, ja  (iii) kaikki virheet, jotka rajoittuvat 16 peräkkäisen bitin purskeeseen.  Kokonaisuudessaan, CRC-CCITT havaitsee 99.998% kaikista virheistä. Toisin sanoen, 1 virhe 50000:sta voi jäädä havaitsematta ja sen kanssa voi sitten elää."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Laitteiden monistaminen"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos halutaan suojautua reaaliaikaisesti mahdollisimman usealta virheeltä, käytetään laitteiden monistamista. Esimerkiksi, kaikki tieto kirjoitetaan kolmelle eri muistipiirille ja tietoa luettaessa tarkistetaan aina, ovatko tiedot edelleen samanlaisia. Jos eivät ole, niin sitten enemmistön kanta voittaa. Jos jokin muistipiiri useamman kerran antaa muista poikkeavan tuloksen, niin se merkitään vialliseksi ja vaihdetaan mahdollisimman pian."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joissakin järjestelmissä on usea suoritin ja kaikki koodi suoritetaan yhtä aikaa niissä kaikissa. Aina kun laskennan tulosta käytetään johonkin tärkeään, niin eri suorittimien antamia laskentatuloksia vertaillaan keskenään ennen operaation toteuttamista. Jos jokin suoritin useamman kerran antaa muista poikkeavan tuloksen, niin se merkitään vialliseksi ja vaihdetaan mahdollisimman pian."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Äärimmäisessä tapauksessa replikoidaan koko tietokonejärjestelmä. Esimerkiksi lentokoneissa on tyypillistä, että telineessä on usea samanlainen tietokone ja ne kaikkea ajavat samaa ohjelmaa. Kun ohjelma yrittää säätää vaikkapa peräsimen asentoa, niin tietokoneet äänestävät. Jos ne ovat kaikki samaa mieltä, niin operaatio sallitaan. Jos ne ovat eri mieltä, niin \"toisinajattelija\" jää vähemmistöön ja sen virheellinen toiminto laitetaan muistiin. Jos sama järjestelmä antaa liian usein virheellisen tuloksen, se merkitään vialliseksi ja koneen insinööriä pyydetään vaihtamaan se telineessä olevaan samanlaiseen varakoneeseen."}]},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Avaruussukkula Columbia"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Avaruussukkula "},{"type":"element","tagName":"a","properties":{"href":"http://www.hq.nasa.gov/office/pao/History/computers/contents.html","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Columbian tietokonejärjestelmät"}]},{"type":"text","value":" oli replikoitu viidellä tietokoneella. Normaalilaskenta tapahtui neljällä samanlaisella tietokoneella, joiden laskennan tuloksia vertailtiin aina ennen sukkulaoperaation suorittamista. Jos jokin näistä neljästä tietokoneesta vikaantui, niin jäljellä oli silti vielä kolme tietokonetta tekemään enemmistöpäätöksiä. Jos miehistö jollain tavoin totesi kaikkien neljän tietokoneen antavan virheellisiä tuloksia, niin ilmeisesti kyseessä oli näitä tietokoneita haittaava ohjelmistovirhe. Äänestäminenhän ei tällaista virhettä voi mitenkään löytää, koska kaikki suorittavat samaa virheellistä ohjelmaa. Tältä varalta mukana oli viides (samanlainen) tietokone, joka suoritti eri versiota ohjelmistosta. Tämän ohjelmiston oli toteuttanut samojen vaatimusmäärittelyjen mukaisesti toinen ohjelmointitiimi, joten saman virheen todennäköisyys oli toivottavasti pieni."}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Massamuistin monistaminen on aivan yleistä, myös ihan kotikoneissa. Kaupasta voi ostaa valmiina esimerkiksi kahden kiintolevyn järjestelmiä, joissa kaikki tiedostot tallennetaan aina kahdelle levylle. Jos yksi levy vikaantuu, niin tiedot ovat vielä tallessa toisella levyllä. Tiedostopalvelimissa käytetään yleensä mutkaisempia mutta kustannuksiltaan halvempia pariteettibitteihin perustuvia ratkaisuja. Tällaiset "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/RAID","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"RAID"}]},{"type":"text","value":"-teknologiaan perustuvat ratkaisut sietävät yhden tai jopa kahden kiintolevyn rikkoutumisen ilman että tietoa häviää."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Cloud_computing","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Pilvipalveluissa"}]},{"type":"text","value":" tiedostot talletetaan yhteen tai useampaan palvelinkeskukseen, joista ne ovat helposti käytettävissä verkon kautta yhdessä tai useammassa tietokonejärjestelmässä. Tiedot replikoidaan useaan palvelinkeskukseen ja kussakin niissä tieto suojataan virheiltä esim. RAID-teknologialla. Tietojen täydellinen katoaminen on hyvin epätodennäköistä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laitteiden monistaminen tiedon muuttumattomuuden turvaamiseksi on siis varsin yleistä. Se, millä tasolla virheiltä suojaaminen tapahtuu, riippuu tietenkin järjestelmän käyttötarkoituksesta. Kotikoneille voi riittää tärkeiden kuvatiedostojen replikointi kahdelle kovalevylle. Toisaalta, ydinvoimalan ohjausjärjestelmän täytyy toimia aina virheettömästi ja olemme valmiita maksamaan siitä aiheutuvat ehkä valtavatkin lisäkustannukset."}]}]},"html":"<div><div>\n<lead>Tässä osiossa tarkastelemme perusmenetelmiä, joilla voidaan valvoa tiedon muuttumattomuutta tietokonejärjestelmissä. Järjestelmään tallennettu tai siellä siirrettävä tieto voi muuttua esimerkiksi laitteistovian, satunnaisen avaruudesta tulleen hiukkasen tai tahallisen tietoturvahyökkäyksen vuoksi. Syystä tai toisesta, järjestelmässä oleva tieto on muuttunut virheelliseksi. Haluaisimme havaita kaikki tällaiset virheet ja mahdollisuuksien mukaan myös korjata ne.</lead>\n</div><h2>Tiedon muuttumattomuuden turvaamisen pääperiaatteet</h2><p>Lähtökohta riittävän hyvän tiedon muuttumattomuuden takaamiselle on hyväksyä se, että virheitä tapahtuu. Perusidea virheiden havaitsemiselle on ottaa mukaan ylimääräisiä bittejä, joiden avulla virhe voidaan havaita ja ehkä jopa korjata. Käytännössä tämä tarkoittaa sitä, että rekistereihin ja muistipiireihin laitetaan ylimääräisiä bittejä ja tiedonsiirtoväyliin ylimääräisiä johtimia. Näiden lisäksi virheen havaitseva koodi pitää myöskin toteuttaa ja sen voi tehdä joko suoraan laitteistolla tai erillisillä suoritettavilla ohjelmilla. Jos ajatellaan esimerkiksi muistiväylän suojaamista, niin nopeusvaatimusten vuoksi kaikki tarkistukset tulee tehdä laitteistototeutuksina.</p><p>Ylimääräiset bitit ja johtimet vaativat ylimääräistä tilaa ja tarkistusten tekeminen vaatii aikaa. Tiedon muuttumattomuuden suojaamisen kustannus maksetaan siten sekä tilassa että ajassa.</p><p>Se, paljonko olemme valmiita maksamaan järjestelmässä olevan tiedon muuttumattomuudesta, riippuu järjestelmästä. Esimerkiksi kotikoneessa on usein tavallista muistia eikä virheen korjaavaa (<a href=\"https://en.wikipedia.org/wiki/ECC_memory\" target=\"_blank\" rel=\"noopener noreferrer\">ECC-muistia</a>), koska tavallinen muisti on halvempaa. Lääketieteellisen sädehoitolaitteen muisti taas on ainakin yhden virheen havaitsevaa ja korjaavaa muistia, koska kukaan ei halua virheellistä määrää säteilyä satunnaisen avaruushiukkasen vuoksi.</p><h2>Tiedon muuttumattomuuden turvausmenetelmien ominaisuudet</h2><p>Luokittelemme tiedon muuttumattomuuden turvausmenetelmiä useiden ominaisuuksien perusteella. Yleensä kuhunkin käyttöön sopivan menetelmän valinta tapahtuu usean ominaisuuden yhdistelmänä, ottaen huomioon riskien hallinta hyväksytyllä tasolla.</p><p>Kuinka monen bitin muuttuminen havaitaan? Menetelmä, joka havaitsee kahden bitin muuttumisen, on parempi kuin sellainen, joka havaitsee vain yhden bitin muuttumisen, mutta se on myös kalliimpi toteuttaa. Esimerkiksi, jos virheet ovat satunnaisia ja yhden virheen esiintymistodennäköisyys on P(virhe)&nbsp;=&nbsp;1:1&nbsp;000&nbsp;000, niin kahden virheen yhtä aikaa tapahtumisen todennäköisyys on sama kuin yhden virheen todennäköisyys potenssiin 2 eli P(2&nbsp;virhettä)&nbsp;= (P(virhe))<sup>2</sup>&nbsp;= 1:1&nbsp;000&nbsp;000&nbsp;000&nbsp;000. Pienlentokoneen järjestelmän suunnittelijat voivat hyvin päättää, että riittää varautua yhteen virheeseen kerrallaan, koska kahden samanaikaisen virheen todennäköisyys on niin pieni. Toisaalta, jos kyseessä on suuri matkustajalentokone, niin olisiko parempi varautua myös kahteen samanaikaiseen virheeseen?</p><p>Kuinka monta viallista bittiä voidaan korjata? Joissakin tapauksissa riittää, että virhe havaitaan ja raportoidaan, jonka jälkeen jokin ulkopuolinen taho korjaa tilanteen. Esimerkiksi verkkoliikenteessä on tyypillistä, että tietoliikennepaketteja katoaa tai menee rikki matkalla. Jos paketissa on viallisia bittejä, niin niitä on helposti niin monta, että niiden korjaaminen ei kuitenkaan onnistu. On helpompi pyytää lähettäjää lähettämään kyseinen paketti uudelleen ja toivoa parasta. Toisaalta, jos muistipiiri on ECC-tyyppinen, niin sitä voi hyvin käyttää ainakin vähän aikaa, vaikka jokin bitti olisikin rikki. Rikkinäisen bitin tieto voidaan lennossa laskea ylimääräisten virheen korjaavien bittien avulla.</p><p>Mikä on virheen kustannus muistitilan tai piirin pinta-alan suhteen? Tämä tarkoittaa yksinkertaisesti sitä, että kuinka paljon ylimääräisiä bittejä tai johtimia tarvitaan (esimerkiksi) 64-bittistä sanaa kohden. Johtimien vetäminen mikropiirin pinnalla voi viedä yllättävän paljon arvokasta pinta-alaa, jolle voisi löytyä muutakin käyttöä - esimerkiksi isompana välimuistina.</p><p>Mikä on virheen kustannus ajassa ja tehdäänkö virheiden havaitsemis/korjauslaskelmat laitteistolla vai ohjelmistolla? Tarkistuskoodin suorittamismenetelmä määräytyy yleensä suoraan siitä, minkä tason tiedosta on kyse. Suorittimen sisäisen väylän tai muistiväylän tiedonsiirron turvaaminen täytyy tapahtua laitteistototeutuksena, koska tarkistus pitää tehdä huomattavasti nopeammin kuin yhden konekäskyn suoritusajassa. Massamuistin, tietoliikenteen ja pilvipalvelimien tiedon tarkistus voidaan hyvin tehdä ohjelmallisesti, koska niiden käyttö on joka tapauksessa hidasta.</p><p>Esimerkkinä tiedot muuttamattomuuden tarkistamisesta voidaan käyttää <a href=\"https://fi.wikipedia.org/wiki/Henkil%C3%B6tunnus\" target=\"_blank\" rel=\"noopener noreferrer\">henkilötunnusta</a>, vaikka tietoa siinä käsitelläänkin merkkikohtaisesti eikä bitteinä. Henkilötunnus on muotoa 120364-121K, jossa alkuosa \"120364\" on syntymäaika ilman vuosisataa, välimerkki ´-´ ilmaisee syntymäajan vuosisadan 1900-luku ('+' on 1800-luku ja 'A' on 2000-luku), \"121\" ilmaisee parittomana lukuna sukupuoleksi miehen ja muutoin uniikin arkistointinumeron tälle henkilölle. Viimeinen merkki ´K´ on tarkistusmerkki, jonka arvo saadaan jakamalla edellä oleva 9-numeroinen luku 120364121 luvulla 31 ja koodaamalla jakojäännös sopivasti. Merkki ´K´ kertoo, että jakojäännös on 18. Matemaattisesti voidaan osoittaa, että tämän tarkistusmerkin avulla löydetään ainakin kaikki yhden merkin virheet ja kaikki kahden merkit vaihtumiset. Rakenteellisena puutteena järjestelmässä on, että välimerkin muuttumattomuutta ei valvota lainkaan. Tämän vuoksi kaikkien käytössä olevien henkilötunnusten on pakko erota toisistaan myös muutoin kuin välimerkin osalta. Tästä taas on seurauksena arkistointinumeroiden loppuminen piakkoin, joten uuden henkilötunnuksen käyttöönotolla alkaa olla kiire. Henkilötunnuksessa havaitaan yhden merkin muuttuminen (ei välimerkissä), mutta virhettä ei voi paikallistaa eikä korjata. Tarkistusmerkin tilakustannus on 9%, koska 11 merkistä yksi on tarkistusmerkki. Tarkistus vaatii jonkin verran laskentaa ja tehdään aina ohjelmallisesti.</p><p>Toinen esimerkki tarkistusmerkeistä on Suomessa käytetty <a href=\"https://fi.wikipedia.org/wiki/IBAN\" target=\"_blank\" rel=\"noopener noreferrer\">IBAN</a> tilinumero. Siinä olevien kahden tarkistusmerkin (numeron) avulla havaitaan kaikki yhden merkin virheet ja useimmat kahden merkin virheet. Kaikki kahden merkin vaihtumiset huomataan samoin kuin useimmat muutkin virheet. Virheitä ei voi korjata lainkaan.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">500015-123                  vanhan muotoinen pankkitilin numero\n5000 1500 0001 23           laajenna pankkiosa 14-numeroiseksi\n5000 1500 0001 23 FI00      lisää loppuun FI00\n5000 1500 0001 23 15 18 00                  muuta  F=&quot;15&quot;, I=&quot;18&quot;\n5000 1500 0001 23 15 18 00 mod 97 = 61      laske modulo 97\n5000 1500 0001 23 FI37      laske 98-61=37 ja aseta 37 FI-merkkien jälkeen\nFI37 5000 1500 0001 23      Siirrä FI-osa alkuun, uusi IBAN-numero</code></pre></div><p>Tarkistusmerkkien kustannus on 2 merkkiä 18:sta eli yli 10%. Tarkistusmerkkien oikeellisuuden laskenta tehdään ohjelmallisesti.</p><h2>Pariteettibitti</h2><p>Bittitasolla yksinkertaisin ja yleinen tarkistusmenetelmä on pariteettibitti. Se on ylimääräinen bitti, jonka avulla tiedon 1-bittien lukumäärästä tehdään parillinen tai pariton. Käytössä sanotaan tuolloin olevan joko <em>parillinen</em> tai <em>pariton pariteetti</em>. Esimerkiksi, 32-bittisessä sanassa voidaan varata 31 bittiä datalle ja 1 bitti pariteettibitille. Tietoa talletettaessa pariteettibitin arvo lasketaan ja talletetaan paikalleen. Joka kerta tietoa luettaessa tarkistetaan, että pariteetti on oikein. Jos se ei ole, niin virhe käsitellään esimerkiksi kutsumalla jotain aliohjelmaa tai aiheuttamalla sopiva keskeytys.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki 15-bittisen datan suojaamisesta parillisella pariteettibitillä,\nkun tietoalkio on 16-bittinen. Pariteettibitti on oikeanpuoleisin bitti\neli bitti numero 0.\n\n0111 0001 1110 0100   - pariteettibitti on 0\n1010 1111 0010 1101   - pariteettibitti on 1</code></pre></div><p>Pariteettibitin kustannus tietoalkiota kohden on 1 bitti, joten suuremmilla tietoalkioilla sen suhteellinen osuus on pienempi.\nPariteettibitin avulla voidaan havaita kaikki yhden bitin virheet, mutta kaikki kahden bitin virheet jäävät havaitsematta.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0111 0001 1110 0000   - bitti nro 2 muuttunut, virheellinen pariteetti\n1010 1111 0010 1011   - bitit nro 2 ja 3 muuttuneet, oikea pariteetti</code></pre></div><p>Pariteettibitin avulla ei voida mitenkään paikallistaa virhettä, joten virheen mahdollinen korjaus täytyy tehdä ylemmällä tasolla ohjelmistoa jollain muulla tavalla. Pariteettibitti kuitenkin sopii hyvin tilanteisiin, joissa yhden bitin virhe on aika pieni, mutta kahden bitin samanaikainen vikaantuminen on hyvin epätodennäköistä. Tällaisissa tilanteissa kolmen bitin yhtäaikaisen vikaantumisen todennäköisyys on vielä paljon pienempi.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">P(1 bitin virhe) = 1:1000 000                 = 1E-6\nP(2 bitin virhe) = 1:1000 000 000 000         = 1E-12\nP(3 bitin virhe) = 1:1000 000 000 000 000 000 = 1E-18</code></pre></div><text-box variant=\"example\" name=\"Richard Hamming\"><p><a href=\"https://en.wikipedia.org/wiki/Richard_Hamming\" target=\"_blank\" rel=\"noopener noreferrer\">Richard Hamming</a> oli tietojenkäsittelytieteen pioneereja. Ennen tietojenkäsittelyyn liittyvää uraansa hän mm. osallistui Manhattan-projektissa atomipommin kehitystyöhön. Vuonna 1945 hän mm. tarkasti laskelmia siitä, tuhoaisiko atomipommi maapallon koko ilmakehän vai ei. Laskelmat oli tehty oikein, mutta hän ollut varma kaikkien oletusten paikkansapitävyydestä. Sodan jälkeen Hamming siirtyi <a href=\"https://en.wikipedia.org/wiki/Bell_Labs\" target=\"_blank\" rel=\"noopener noreferrer\">Bell Labs</a>'ille ja työskenteli osan aikaa samassa työhuoneessa informaatiotieteen isäksi kutsutun <a href=\"https://en.wikipedia.org/wiki/Claude_Shannon\" target=\"_blank\" rel=\"noopener noreferrer\">Claude Shannonin</a> kanssa.</p></text-box><h2>Hamming-etäisyys</h2><p>Richard Hamming tutki 1950-luvulla koodatun tiedon muuttumattomuutta eri koodijärjestelmissä. <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\" rel=\"noopener noreferrer\">Hamming-etäisyys</a> on niiden bittien lukumäärän jonka mukaisen määrän bittejä täytyy muuttua, jotta jokin laillinen merkki muuttuu toiseksi saman koodijärjestelmän toiseksi lailliseksi merkiksi. Mitä isompi Hamming-etäisyys tietyssä koodausjärjestelmässä on, sitä parempi. Jos virheitä (bittien muuttumisia) tapahtuu vähemmän kuin Hamming-etäisyyden verran, niin tuloksena on aina virheelliseksi havaittavissa oleva tietoalkio.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">7-bittinen ASCII-merkistö\n\n&#39;A&#39; = 0x41 =  100 0001\n&#39;B&#39; = 0x42 =  100 0010   Hamming-etäisyys (A,B) = 2\n&#39;C&#39; = 0x43 =  100 0011   Hamming-etäisyys (B,C) = 1</code></pre></div><p>Koodijärjestelmän Hamming-etäisyys on pienin Hamming-etäisyys kyseisen järjestelmän merkkien välillä. Edellisen esimerkin ASCII-koodiston Hamming-etäisyys on siten yksi. Tämä tarkoittaa, että yhden bitin virheitä ei voi havaita. Esimerkiksi, merkin 'B' viimeisen bitti muuttuminen nollasta ykköseksi muuttaa sen merkiksi 'C', eikä virhe ole mitenkään havaittavissa.</p><p>Jos 7-bittiseen ASCII-koodistoon lisätään pariteetti-bitti, niin koodijärjestelmän Hamming-etäisyys kasvaa kahteen. Nyt kaikki yhden bitin virheet havaitaan ja järjestelmä on paljon turvallisempi. Jos merkin 'B' bitti 0 muuttuu nyt ykkösestä nollaksi, niin virhe havaittaisiin nyt siitä, että pariteettibitti on väärin.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">7-bittinen ASCII-merkistö + pariteettibitti (bitti 7)\nParillinen pariteetti\n\n&#39;A&#39; = 0x41 = 0100 0001\n&#39;B&#39; = 0x42 = 0100 0010   Hamming-etäisyys (A,B) = 2\n&#39;C&#39; = 0xC3 = 1100 0011   Hamming-etäisyys (B,C) = 2\nmuuttunut &#39;B&#39; = 0100 0011   virheellinen data, pariteetti on väärin</code></pre></div><p>Pariteeettibitin kanssa kyseessä ei ole enää sama koodijärjestelmä. Esimerkiksi 'C' on ASCII-koodissa 0x43, kun se uudessa koodausjärjestelmässä olisi 0xC3.</p><h2>Hamming-koodi</h2><p><a href=\"https://en.wikipedia.org/wiki/Hamming_code\" target=\"_blank\" rel=\"noopener noreferrer\">Hamming-koodissa</a> data-bittien joukkoon lisätään useita pariteetti-bittejä, joiden avulla yhden bitin virheet voidaan paikallistaa ja sen jälkeen korjata.  Esimerkiksi nyt myytävissä virheenkorjaavissa ECC-muistipiireissä virheenkorjaus useimmiten edelleen perustuu Hamming-koodiin, vaikka myös muita menetelmiä on käytössä.</p><p>Hamming-koodin perusidea on järjestää data-bitit erilaisiin joukkoihin (pariteettijoukkoihin) sillä tavoin, että jokainen databitti kuuluu uniikkiin joukkoon näitä ryhmiä. Jokaisella pariteettijoukolla on sitten oma pariteettibittinsä. Jos joku bitti muuttuu, niin virheellisen bitin sijainti voidaan päätellä virheellisistä pariteettibiteistä. Tarkemmin sanoen, virhe paikallistetaan niistä pariteettijoukoista, joihin virheellinen bitti kuuluu.</p><h3>Hamming(7,4) esimerkki</h3><p><a href=\"https://en.wikipedia.org/wiki/Hamming(7,4)\" target=\"_blank\" rel=\"noopener noreferrer\">Hamming(7,4)</a> esimerkki kuvaa hyvin Hamming-koodin periaatteen. Siinä seitsemästä tietoalkion bitistä neljä on data-bittejä ja niitä vartioi kolme pariteettibittiä.</p><!-- kuva: ch-7-2-Hamming-7-4  --><p><img src=\"/6b394d4d11603bab898c183c472e73b7/ch-7-2-Hamming-7-4.svg\" alt=\"Hamming(7,4) esimerkki, jossa 7 tietobitistä 4 kappaletta on databittejä ja 3 pariteettibittejä. Kuvassa on neljä osaa: (a), (b), (c) ja (d). Osassa (a) on databitit a, b, c ja d, joiden arvot ovat a=0, b=1, c=1 ja d=0. Bitti b on keskellä, bitti a on bitin b vasemmalla puolella, bitti c on bitin b yläpuolella oikealla ja bitti d on bitin b alapuolella oikealla. Bitit a, b ja c kuuluvat (pariteetti) joukkoon A. Bitit a, b ja d kuuluvat joukkoon B. Bitit b, c ja d kuuluvat joukkoon C. Osassa (b) ovat myös joukkojen parilliset pariteettibitit mukana: A=0, B=1 ja C=0. Joukot on piirretty ympyröinä, joihon kuuluvat kunkin joukon data- ja pariteettibitit. Osassa (c) alhaalla oikealla oleva databitti d on vaihtunut virheelliseen arvoon 1, jolloin joukkojen B ja C pariteettibitit B=1 ja C=0 ovat väärin. Osassa (d) databitti d on korjattu oikeaksi arvoon 0 ja kaikki pariteettibitit ovat taas oikein.\"></p><div>\n<illustrations motive=\"ch-7-2-Hamming-7-4\"></illustrations>\n</div><p>Lähtötilanteessa (a) on merkittynä databittien arvot ja pariteettijoukot (A, B ja C). Huomaa, että jokainen databitti kuuluu uniikkiin ryhmään pariteettijoukkoja. Esimerkiksi vasemmanpuolimmainen databitti kuuluu joukkoihin A ja B, mutta ei joukkoon C. Tällainen joukkoihin kuuluminen ei päde millekään muulle bitille.</p><p>Jokaiselle joukolle on oma pariteettibittinsä. Tilanne (b) näyttää kunkin pariteettibitin arvon, parillista pariteettia käyttäen.</p><p>Ajatellaan nyt, että yksi data-biteistä (oikealla alhaalla oleva) muuttuu syystä tai toisesta virheelliseksi, jolloin tilanne on kohdan (c) mukainen. Kyseinen databitti kuuluu joukkoihin B ja C, joten niiden pariteettibitit ovat nyt virheellisiä.</p><p>Virheen korjaus tapahtuu useassa vaiheessa. Ensinnäkin, jokin pariteettibiteistä on väärin, mikä indikoi jonkinlaista virhettä jossain. Seuraavaksi havaitaan virheen olevan joukoissa B ja C, mutta ei joukossa A. Vain yksi bitti täyttää nämä ehdot, joten virheellisen bitin täytyy olla oikealla alhaalla oleva databitti. Lopuksi virheellinen bitti <em>käännetään</em> (flipataan) kohdan (d) mukaisesti toisin päin, jolloin sen arvo tulee korjatuksi. Binäärijärjestelmä on tässä tosi kätevä, kun virheelliselle binääriarvolle on vain yksi oikea vaihtoehto. Jos desimaalinumeron tiedettäisiin olevan väärin, niin silti olisi jäljellä yhdeksän muuta vaihtoehtoa.</p><p>Entäpä jo virhe onkin pariteettibitissä eikä databitissä? Ei huolta, Hamming-koodi toimii myös siinä tapauksessa. Esimerkiksi, jos joukon A pariteettibitti (0) vaihtuu ykköseksi, niin silloin joukon A pariteettibitti on väärin ja muiden joukkojen pariteettibitit ovat oikein. Ainoa bitti, joka kuuluu joukkoon A mutta ei joukkoihin B tai C, on joukon A pariteettibitti. Virhe on näin paikallistettu ja voidaan korjata. Tilanne on vähän samanlainen kuin jonkin varoitusvalon rikkoutuminen autossa. Itse auton toiminnoissa ei ole mitään ongelmaa, mutta turvajärjestelmän toimivuuden vuoksi vika pitää silti korjata.</p><p>Esimerkin Hamming-koodin kustannus on aika korkea. Lähes puolet (3/7 = 43%) biteistä ovat pariteettibittejä. Lisäksi vaatii aika paljon laskenta-aikaa asettaa pariteettibitit paikalleen ja tarkistaa niiden oikeellisuus. Todellisuudessa käytettävä Hamming-koodi on yksinkertaisuudessaan vielä nerokkaampi ja <a href=\"https://en.wikipedia.org/wiki/Scalability\" target=\"_blank\" rel=\"noopener noreferrer\">skaalautuu</a> hyvin myös suurempien data-alkioden virheenkorjaukseen. Virheellisen bitin sijainnin päättely tapahtuu yksinkertaisen yhteenlaskun avulla.</p><h3>Virheen korjaava Hamming-koodi</h3><p>Hamming-koodissa pariteettijoukot määritellään ovelasti ja joukot voivat ovat erikokoisia. Ensinnäkin on huomattava, että bitit numeroidaan (esimerkiksi) oikealta päin alkaen ykkösestä (ei nollasta, kuten yleensä bittien numeroinnin kanssa on). Seuraavaksi tarkastellaan bitin numeron binääriesitystä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Tietoalkio (7 bittiä):     100 1100\nBitin numero:              765 4321\n\nBitin      Bitin numeron\nnumero     binääriesitys\n\n  1          001\n  2          010\n  3          011\n  4          100\n  5          101\n  6          110\n  7          111\n  ...        ...</code></pre></div><p>Kukin tietoalkion bitti kuuluu joukkoon <em>2^(i-1)</em>, jos bitin numeron binääriesityksessä i:nnes bitti oikealta on 1. Äskeisessä esimerkissä joukkoon 1 kuuluvat siten bitit 1, 3, 5 ja 7. Joukkoon 2 kuuluvat bitit 2, 3, 6 ja 7. Joukkoon 4 kuuluvat bitit 4, 5, 6 ja 7.</p><p>Toisin päin katsottuna, se, mihin joukkoihin kukin bitti kuuluu, näkyy suoraan bitin numeroesityksestä. Bitti 1 kuuluu joukkoon 1, mutta ei joukkoihin 2 tai 4. Bitti 3 kuuluu joukkoihin 1 ja 2, mutta ei joukkoon 4. Bitti 7 kuuluu kaikkiin joukkoihin 1, 2 ja 4. Jokainen bitti kuuluu erilaiseen ryhmään joukkoja, koska kunkin bitin numeron binääriesitys on uniikki.</p><p>Lopuksi määritellään, että kaikki bitit, joiden numero on kakkosen potenssi, ovat pariteettibittejä. Näin jokaiseen joukkoon saadaan täsmälleen yksi pariteettibitti.</p><p>Esimerkiksi, 7-bittisellä tietoalkiolla bitit 1, 2 ja 4 ovat pariteettibittejä, jotka määrittelevät kukin oman pariteettijoukkonsa. Joukot nimetään sen pariteettibitin numeron perusteella. Täten bitti 1 on joukon 1 pariteettibitti, bitti 2 joukon 2 pariteettibitti, jne. Vastaavasti 136-bittisellä tietoalkiolla bitit 1, 2, 4, 8, 16, 32, 64 ja 128 ovat pariteettibittejä. 136-bittisellä tietoalkiolla on näin 128 data-bittiä ja 8 pariteettibittiä.</p><p>Jos tarvitsemme 32 databittiä, niin niitä turvaamaan tarvitaan 6 pariteettibittiä (bitit 1, 2, 4, 8, 16 ja 32). Tietoalkiossa pariteettibitit ovat databittien välissä omilla paikoillaan. Yhteensä tarvitaan siis 38 bittiä. Tietoa käsitellessä tietoalkiosta käytetään vain databittejä, mutta tiedon muuttumattomuutta varmistettaessa käytetään kaikkia bittejä.</p><p>Yhden virheellisen bitin paikallistaminen tapahtuu vastaavasti kuten aikaisemmin esitettiin. Käytämme tässä esimerkkinä 7-bittistä tietoalkiota 100 1100, jossa on neljän bitin data 1001 (bitit 3, 5, 6 ja 7) ja kolme pariteettibittiä (bitit 1, 2 ja 4). Käytössä on parillinen pariteetti.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                Alkuperäinen  Virheellinen  Korjattu\n\nTietoalkio:        100 1100    110 1100     100 1100\nBitin numero:      765 4321    765 4321     765 4321\nPariteettivirhe:                   1 1</code></pre></div><p>Esimerkissä bitti numero 6 on kääntynyt virheelliseksi. Bitti 6 kuuluu joukkoihin 2 ja 4, joten pariteettibitit 2 ja 4 ovat nyt väärin. Virheen olemassaolo havaitaan jälleen siitä, että jokin pariteettibitti on väärin. Virhe paikallistetaan yksinkertaisesti laskemalla yhteen virheen indikoivien pariteettibittien numerot, eli tässä tapauksessa 2+4=6. Virhe korjataan kääntämällä bitti 6. Lopuksi tarkistetaan vielä, että kaikki pariteettibitit ovat nyt oikein. Jos ne eivät ole, niin virheitä oli useampi ja peli on menetetty.</p><p>Entäpä, jos virhe onkin vain pariteettibitissä? Se ei haittaa, sillä pariteettibitti sisältyy vain yhteen (omaan) pariteettijoukkoon ja virheellisen bitin sijainti identifioituu aivan oikein.</p><p>Useamman bitin virheitä ei välttämättä havaita alkuaankaan. Esimerkiksi, jos edellisen esimerkin tietoalkiossa 100 1100 kaksi bittiä (bitit 1 ja 6) kääntyvät virheellisiksi (tietoalkioksi 110 1101), niin kaikki pariteettibitit ovat väärin. Sen mukaisesti virheelliseksi bitiksi lasketaan 1+2+4=7 eli bitti 7 on muka virheellinen. Kun se käännetään vielä ympäri, saadaan tietoalkioksi 010 1101. Siinä ei ole pariteettivirheitä, mutta sen sijaan 3 virheellistä bittiä. Aina ei voi voittaa!</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                Alkuperäinen   Virheellinen   Korjattu\n                 0 virhettä     2 virhettä    3 virhettä\n\nTietoalkio:      100 1100       110 1101        010 1101\nBitin numero:    765 4321       765 4321        765 4321\nPariteettivirhe:                    1 11</code></pre></div><div>Hamming-koodin tilakustannus on sitä pienempi, mitä suuremmasta tietoalkiosta on kyse, koska vain kakkosen potenssin numeroiset bitit (eli muotoa 2<sup>k</sup>, k = 0, 1, 2, ...) ovat pariteettibittejä. Esimerkiksi, 1024 databitin turvaamiseen tarvitaan vain 11 ylimääräistä pariteettibittiä järjestysnumeroiltaan 2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, ..., 2<sup>10</sup> = 1, 2, 4, ..., 1024.</div><p>Hamming-koodin aikakustannus vaihtelee sen mukaan, toteutetaanko tiedon muuttumattomuuden tarkistus laitteistolla vai ohjelmistolla. Jos Hamming-koodia käytetään muistipiirin tai väylän suojaamiseen, niin toteutus täytyy tehdä laitteistolla, koska toteutuksen täytyy olla paljon nopeampi kuin yhden konekäskyn suoritusaika. Esimerkiksi ECC-muistipiiriä käytettäessä muistipiiri laskee ja sijoittaa pariteettibitit paikalleen jokaisen muistiinkirjoituksen yhdessä. Vastaavasti muistia luettaessa muistipiiri tarkistaa luetun tiedon muuttumattomuuden suoraan laitteistolla, ennen kuin se antaa tiedon väylää pitkin eteenpäin.</p><p>Laitteistototeutuksessa ei virheen ilmetessä tarvita edes yhteenlaskua. Riittää, kun virheellisten pariteettibittien sijainnit laitetaan paikalleen johonkin sisäiseen rekisteriin ja tulos <em>tulkitaan</em> kokonaisluvuksi!</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                          Virheellinen data\n                              1 virhe\n\nTietoalkio:                   110 1100\nBitin numero:                 765 4321\nVirheelliset pariteettibitit:     1 1\nVirheen sijainti:             000 1010  = 6</code></pre></div><p>Hamming-koodin voi toteuttaa myös ohjelmistolla, jolloin se vaatii jonkin verran konekäskyjä bittimanipulaatioiden toteuttamiseksi. Se on työlästä puuhaa, mutta ei kovin monimutkaista.</p><p>Käytännössä pelkkä virheen paikallistaminen ja korjaaminen ei tietenkään riitä. Se on vain tilapäinen lääke havaittuun virhetilanteeseen. Virheistä täytyy pitää kirjaa. Jos virhe toistuu saman muistipiirin kohdalla usein, niin ilmeisesti muistipiirissä on vika, joka pitää korjata jollain tavoin. Useimmiten se tarkoittaa muistipiirin vaihtamista uuteen. Jos vika on muistiväylässä, sen korjaaminen on vielä hankalampaa ja voi vaatia koko laitteiston uusimisen.</p><p>Hamming-koodista on useita laajennuksia. Esimerkiksi lisäämällä pariteettibitti 0 voidaan havaita kaikki kahden bitin virheet, mutta niitä ei voi korjata. Lisäämällä vielä enemmän pariteettibittejä pystytään korjaamaan myös kaikki kahden bitin virheet, jne. Sopiva tiedon muuttumattomuuden suojaustaso määritellään tapauskohtaisesti sen mukaan, kuinka todennäköisiä virheet ovat ja kuinka suuret kustannukset havaitsemattomista (tai ei-korjattavissa olevista) virheistä aiheutuu.</p><p>Mitä lähempänä suoritinta ollaan, sitä tärkeämmäksi tulee suojautuminen (satunnaisilta) virheiltä. Suorittimen sisäisissä rekistereissä oleva ja väylillä liikkuva tieto on tärkeätä suojata muutoksilta. Kotikoneiden keskusmuisti voi usein olla suojaamatonta, mutta ainakin palvelinkoneiden muisti on yleensä ECC-muistia. ECC-muisti ei riitä, ellei myös muistiväylä ole virheiltä suojattu. Muistipiirit voi vaihtaa halutessaan kalliimpiin ECC-muisteihin. Väylää ei voi vaihtaa., koska se on kiinteä osa järjestelmää. Tämän vuoksi väylä on yleensä valmiiksi suojattu Hamming-koodilla.</p><h2>Tiedon muuttumattomuus tietoliikenteessä</h2><p>Hamming-koodi ei sovi tiedon muuttumattomuuden havaitsemiseen sellaisessa tapauksessa, jossa muuttuneiden bittien määrä on todennäköisesti suurempi. Esimerkiksi tietoliikenteessä on tyypillistä, että jos virheitä tulee, niin sitten niitä tulee paljon. Virheiden korjaaminen on siten yleensä käytännössä mahdotonta tai sitten sen kustannus ylimääräisten bittien osalta aivan liian suuri.</p><p>Käytännössä tietoliikenteessä riittää, kun tiedon muuttuminen havaitaan jollain tavoin. Sen jälkeen joko pyydetään lähettäjää lähettämään viallinen tietoliikennepaketti uudelleen tai vain jätetään kuittaamatta viallinen paketti. Jälkimmäisessä tapauksessa lähettäjä vähän ajan päästä arvelee paketin kadonneen matkalla ja lähettää sen uudelleen.</p><p>Tietoliikennepakettien tiedon muuttumattomuutta suojataan tarkistussummien avulla. Yksinkertainen tapa on tulkita kaikki paketin (esim. 4KB tai 4MB) sanat kokonaisluvuiksi ja laskea niiden summa. Summa voi olla kovinkin suuri (esim. 0x1234567890AB), mutta otetaan talteen siitä vain esimerkiksi 32 viimeistä bittiä tarkistussummaksi (0x567890AB). Tarkistussumma lähetetään paketin databittien mukana vastaanottajalle. Vastaanottaja laskee tarkistussumman uudestaan itse ja vertailee sitä saamaansa. Jos ne ovat erilaisia, jotain on muuttunut matkalla. On hyvin epätodennäköistä, että tarkistussumma olisi oikein satunnaisten virheiden jälkeen. Se on tietenkin mahdollista, mutta silti epätodennäköistä.</p><p>Edellä mainittua yksinkertaiseen <a href=\"https://fi.wikipedia.org/wiki/Modulaarinen_aritmetiikka\" target=\"_blank\" rel=\"noopener noreferrer\">modulo-aritmetiikkaan</a> perustuvan tarkistussumman asemesta käytetään parempia matemaattisesti hyväksi havaittuja tarkistussummia. Niillä on mahdollista myös suojautua tahallista tiedon muuttumattomuuteen kohdistuvaa <em>hyökkäystä</em> vastaan, koska tarkistussumman väärentäminen on matemaattisesti vaikeata.</p><p>Yleisesti käytössä oleva tietoliikenteen tarkistussummamenetelmä on Wesley Petersonin 1961 kehittämä  <a href=\"https://en.wikipedia.org/wiki/Cyclic_redundancy_check\" target=\"_blank\" rel=\"noopener noreferrer\">Cyclic Redundancy Check</a> (CRC), jossa tarkistussumma on esimerkiksi 32-bittinen. CRC:stä on useampi variantti eri käyttötarkoituksiin. Esimerkiksi, 16-bittinen variantti CRC-CCIIT löytää (i) kaikki yhden, kahden ja kolmen bitin virheet, (ii) kaikki virheet, joissa virheellisten bittien lukumäärä on pariton, ja  (iii) kaikki virheet, jotka rajoittuvat 16 peräkkäisen bitin purskeeseen.  Kokonaisuudessaan, CRC-CCITT havaitsee 99.998% kaikista virheistä. Toisin sanoen, 1 virhe 50000:sta voi jäädä havaitsematta ja sen kanssa voi sitten elää.</p><h2>Laitteiden monistaminen</h2><p>Jos halutaan suojautua reaaliaikaisesti mahdollisimman usealta virheeltä, käytetään laitteiden monistamista. Esimerkiksi, kaikki tieto kirjoitetaan kolmelle eri muistipiirille ja tietoa luettaessa tarkistetaan aina, ovatko tiedot edelleen samanlaisia. Jos eivät ole, niin sitten enemmistön kanta voittaa. Jos jokin muistipiiri useamman kerran antaa muista poikkeavan tuloksen, niin se merkitään vialliseksi ja vaihdetaan mahdollisimman pian.</p><p>Joissakin järjestelmissä on usea suoritin ja kaikki koodi suoritetaan yhtä aikaa niissä kaikissa. Aina kun laskennan tulosta käytetään johonkin tärkeään, niin eri suorittimien antamia laskentatuloksia vertaillaan keskenään ennen operaation toteuttamista. Jos jokin suoritin useamman kerran antaa muista poikkeavan tuloksen, niin se merkitään vialliseksi ja vaihdetaan mahdollisimman pian.</p><p>Äärimmäisessä tapauksessa replikoidaan koko tietokonejärjestelmä. Esimerkiksi lentokoneissa on tyypillistä, että telineessä on usea samanlainen tietokone ja ne kaikkea ajavat samaa ohjelmaa. Kun ohjelma yrittää säätää vaikkapa peräsimen asentoa, niin tietokoneet äänestävät. Jos ne ovat kaikki samaa mieltä, niin operaatio sallitaan. Jos ne ovat eri mieltä, niin \"toisinajattelija\" jää vähemmistöön ja sen virheellinen toiminto laitetaan muistiin. Jos sama järjestelmä antaa liian usein virheellisen tuloksen, se merkitään vialliseksi ja koneen insinööriä pyydetään vaihtamaan se telineessä olevaan samanlaiseen varakoneeseen.</p><text-box variant=\"example\" name=\"Avaruussukkula Columbia\"><p>Avaruussukkula <a href=\"http://www.hq.nasa.gov/office/pao/History/computers/contents.html\" target=\"_blank\" rel=\"noopener noreferrer\">Columbian tietokonejärjestelmät</a> oli replikoitu viidellä tietokoneella. Normaalilaskenta tapahtui neljällä samanlaisella tietokoneella, joiden laskennan tuloksia vertailtiin aina ennen sukkulaoperaation suorittamista. Jos jokin näistä neljästä tietokoneesta vikaantui, niin jäljellä oli silti vielä kolme tietokonetta tekemään enemmistöpäätöksiä. Jos miehistö jollain tavoin totesi kaikkien neljän tietokoneen antavan virheellisiä tuloksia, niin ilmeisesti kyseessä oli näitä tietokoneita haittaava ohjelmistovirhe. Äänestäminenhän ei tällaista virhettä voi mitenkään löytää, koska kaikki suorittavat samaa virheellistä ohjelmaa. Tältä varalta mukana oli viides (samanlainen) tietokone, joka suoritti eri versiota ohjelmistosta. Tämän ohjelmiston oli toteuttanut samojen vaatimusmäärittelyjen mukaisesti toinen ohjelmointitiimi, joten saman virheen todennäköisyys oli toivottavasti pieni.</p></text-box><p>Massamuistin monistaminen on aivan yleistä, myös ihan kotikoneissa. Kaupasta voi ostaa valmiina esimerkiksi kahden kiintolevyn järjestelmiä, joissa kaikki tiedostot tallennetaan aina kahdelle levylle. Jos yksi levy vikaantuu, niin tiedot ovat vielä tallessa toisella levyllä. Tiedostopalvelimissa käytetään yleensä mutkaisempia mutta kustannuksiltaan halvempia pariteettibitteihin perustuvia ratkaisuja. Tällaiset <a href=\"https://en.wikipedia.org/wiki/RAID\" target=\"_blank\" rel=\"noopener noreferrer\">RAID</a>-teknologiaan perustuvat ratkaisut sietävät yhden tai jopa kahden kiintolevyn rikkoutumisen ilman että tietoa häviää.</p><p><a href=\"https://en.wikipedia.org/wiki/Cloud_computing\" target=\"_blank\" rel=\"noopener noreferrer\">Pilvipalveluissa</a> tiedostot talletetaan yhteen tai useampaan palvelinkeskukseen, joista ne ovat helposti käytettävissä verkon kautta yhdessä tai useammassa tietokonejärjestelmässä. Tiedot replikoidaan useaan palvelinkeskukseen ja kussakin niissä tieto suojataan virheiltä esim. RAID-teknologialla. Tietojen täydellinen katoaminen on hyvin epätodennäköistä.</p><p>Laitteiden monistaminen tiedon muuttumattomuuden turvaamiseksi on siis varsin yleistä. Se, millä tasolla virheiltä suojaaminen tapahtuu, riippuu tietenkin järjestelmän käyttötarkoituksesta. Kotikoneille voi riittää tärkeiden kuvatiedostojen replikointi kahdelle kovalevylle. Toisaalta, ydinvoimalan ohjausjärjestelmän täytyy toimia aina virheettömästi ja olemme valmiita maksamaan siitä aiheutuvat ehkä valtavatkin lisäkustannukset.</p></div>","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}},"allPages":{"edges":[{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}