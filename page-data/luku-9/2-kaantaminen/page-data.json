{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-9/2-kaantaminen","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Tässä aliluvussa esittelemme pääpiirteet, joilla käännösyksikkö käännetään objektimoduuliksi."}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Objektimoduulin rakenne"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käännöksessä luodaan objektimoduuli, joka myöhemmin linkitetään muihin objektimoduuleihin. Objektimoduulissa on kolme tärkeätä tietorakennetta: konekielinen ohjelmakoodi, linkityksen tarvitsemat tiedot "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"uudelleensijoitustaulussa"}]},{"type":"text","value":" ja kaikki ohjelman käytämät symbolit ja niiden arvot "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"symbolitaulussa"}]},{"type":"text","value":". Symbolitaulu voi olla irrallinen tietorakenne tai sitten se on osa uudelleensijoitustaulua."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Objektimoduulissa on koodi konekielisessä muodossa ja kaikki moduulin sisäiset viitteet jo oikein, mutta vain tämän objektimoduulin omassa (pienehkössä) osoiteavaruudessa."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"käännösyksikkö             osoite  data tai konekäskyn kentät\n                                         opcode Rj Ri M Addr\nx     dc 5             -->     0:                        5\ny     dc 7             -->     1:                        7\n      load r1, x       -->     2:           2  1  0 1    0 *\n      add  r1, y       -->     3:          17  1  0 1    1 *\n      ...\n      call sp, matmul  -->    34:          49  6  0 1    0 *\n      ...\naver  pushr sp         -->    77:          53  6  0 0    0 *\n      ...\n\n      svc  sp, =halt   -->   323:          112 6  0 0   11"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Objektimoduulissa pitää jollain tavoin merkitä sellaisten viitteet "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"moduulin sisäisiin osoitteisiin"}]},{"type":"text","value":" sen omassa muistiavaruudessa, koska nämä pitää päivittää linkityksen yhteydessä. Ylläolevassa esimerkissä viitteet muuttujiin x (osoite 0) ja y (osoite 1) ovat tällaisia. Yleisesti ottaen linkityksen aikana päivitettävien osoitteiden sijainnit pidetään kääntäjän luomassa uudelleensijoitustaulussa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Objektimoduulissa voi olla myös viitteitä dataan tai koodiin muissa moduuleissa. Ylläolevassa esimerkissä muistipaikassa 34 on kutsu jossakin toisessa moduulissa olevaan aliohjelmaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"matmul"}]},{"type":"text","value":", jonka osoitetta ei ole lainkaan vielä tiedossa. Sitten kun tieto linkityksen yhteydessä löytyy, se pitää laittaa paikalleen tämän moduuliin koodiin. Myös tällaisten linkityksen aikana päivitettävien  "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"moduulin ulkopuolisten osoitteiden"}]},{"type":"text","value":" sijainnit ovat em. uudelleensijoitustaulussa, sen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"IMPORT"}]},{"type":"text","value":"-osiossa (import-taulussa)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lisäksi uudelleensijoitustaulussa on vielä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"EXPORT"}]},{"type":"text","value":"-osio (export-taulu), jossa on tieto niistä data- tai koodiosoitteista, joihin saa tässä moduulissa viitata "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"muista moduuleista"}]},{"type":"text","value":". Ylläolevassa esimerkissä esimerkiksi funktio "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"aver"}]},{"type":"text","value":" osoitteessa 77 voisi olla tällainen muiden moduulien kutsuttavissa oleva rutiini."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Symbolitaulu"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Symbolitaulussa on siis kaikki ohjelman käyttämät symbolit ja niiden arvot. Joidenkin symbolien arvot annetaan, joidenkin arvot päätellään käännösmoduulista käännösvaiheessa, joidenkin arvot selviävät linkitysvaiheessa ja joidenkin vasta suoritusaikana."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kussakin (korkean tason ja symbolisen konekielen) ohjelmointikielessä on  merkittävä joukko etukäteen määriteltyjä symboleja, joiden arvot löytyvät myös symbolitaulusta. Tällaisia ovat esimerkiksi symbolisen konekielen operaatiokoodien nimet (add, comp, jump, etc), laiterekisterien nimet (r0, r4, sp, etc), laitteiden nimet (crt, kbd, etc) ja käyttöjärjestelmäpalvelujen nimet (halt, time, etc)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkiksi symbolisen konekielen equ-valekäskyllä määritellään jollekin symbolille arvo ja se talletetaan symbolitauluun. Moduulin omien tietorakenteiden sijainnit ja niitä vastaavien symbolien arvot määräytyvät täysin siitä, missä järjestyksessä ne on kirjoitettu käännösyksikön ohjelmakoodiin. Ihan vastaavasti kaikki koodissa olevat käskyjen osoitteet määräytyvät niiden tekstuaalisen sijainnin perusteella käännösyksikössä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kun moduulissa viitataan moduuliin ulkopuoliseen dataan tai koodiin, niin niitä vastaavien symbolien arvot selviävät vasta linkitysvaiheessa. Dynaamisesti linkitettävien moduulien osalta symbolien arvot tarkentuvat vasta suoritusaikana."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos dynaamista linkitystä ei ole käytössä, niin koko symbolitaulun voi jättää pois latausmoduulista. Kaikilla symboleilla  on jo arvot ja ne on päivitetty koodiin. Usein symbolitaulu pidetään kuitenkin tallessa ainakin ohjelmiston kehitysaikana, jotta sen avulla voidaan tehdä järkevämpiä virheilmoituksia. Ohjelmoijalle on paljon mukavampaa lukea \"Integer overflow for variable X in line 4226 in module Statistics\" kuin \"Integer overflow in 0x00004321\". Toisaalta taas älykellon käyttäjä ei missään tapauksessa halua nähdä kumpaakaan noista ilmoituksista ja symbolitaulun vaatiman muistitilan voi käyttää paremminkin."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Literaalit"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Literaali tarkoittaa ohjelmassa olevia vakioita. Ne on usein sijoitettu omalle muistialueelleen, eikä tällaisella "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"literaalialueella"}]},{"type":"text","value":" olevia arvoja saisi muuttaa. On ilmeisen virhealtista muuttaa literaalin Sata arvoksi 101, jne. Esimerkkikonekielessä ttk-91 kaikki vakiot ovat literaaleja, mutta niiden muuttamattomuutta valvotaan vain ohjelmointikurilla. Useissa järjestelmissä vakiot talletetaan omalle suojatulle muistisegmentille. Siellä olevia tietoja voi lukea ja niitä voi lisätä, mutta tietoja ei voi muuttaa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joissakin kielissä kaikki merkkijonot ovat literaaleja. Joissakin kielissä kaikki koodissa olevat isot vakiot ovat literaaleja, jolloin ison vakion käyttäminen koodissa automaattisesti johtaa uuden vakion määrittelyyn."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"load r2, \"mystring\" -->  Lmystring ds \"mystring\" ; ei ttk-92:ssä\n                                   load r2, =Lmystring ; merkkijonon osoite\n\nload r1, =800000    -->  L800000 dc 800000\n                                 load r1, L800000   ; viittaus muistiin, ei käskyn vakio-osaan"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Literaalia ei saisi välittää viiteparametrina, koska tällöin kutsuttu rutiini voisi (vahingossa) muuttaa sen arvoa. Useissa kielissä esimerkiksi kaikki merkkijonot välitetään joka tapauksessa viiteparametreina. Arvon muutoksen voi kuitenkin estää, jos literaalit on talletettu suojatulle literaalialueelle."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joissakin kielissä kaikki koodissa olevat vakiot ovat literaaleja. Tämä tekee vakioiden käsittelystä linjakasta, mutta toisaalta pienten vakioiden talletus literaalialueelle hidastaa suoritusta verrattuna tilanteeseen, jossa ne talletettaisiin käskyjen vakiokenttiin."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"load    r1,=5    -->    L5  dc 5\n                        load r1, L5"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Jos literaalin arvoja voisi muuttaa, niin myös seuraava koodinpätkä olisi mahdollinen."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"load    r1, =5    -->    L5  dc 5\n                         load r1, L5\nstore   r1, =6    -->    L6  dc 6\n                         store r1, L6"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ohjelmointikuri on selvästi pettänyt ja vakion L6 arvo on nyt 5, mistä seuraisi jatkossa luultavasti hyvin paljon ongelmia.  Joissakin (vanhemmissa) kielissä oli mahdollista kirjoittaa lause \"6=5;\", millä oli juuri sama lopputulos. Nykyisissä kielissä tämä ei ole mahdollista, koska ensinnäkin kielen määrittely estää sen ja toiseksi literaalit sijaitsevat suojatulla muistialueella."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Makrot"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Useissa korkean tason kielissä ja symbolisissa konekielissä on mahdollisuus käyttää "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"makroja"}]},{"type":"text","value":". Makrot ovat usein toistettavia koodisarjoja ja niiden käyttö helpottaa ohjelmointia. Niissä voi olla parametreja, minkä vuoksi ne voi joskus sekoittaa aliohjelmiin vaikka ne ovat täysin erilaisia."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Makrot käsitellään ennen kääntämistä. Ennen varsinaista käännöstä koko ohjelmakoodi käydään läpi ja kukin makro "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"laajennetaan"}]},{"type":"text","value":" tekstuaalisesti sitä vastaavaksi koodinpätkäksi. Tämän vuoksi makroissa voi käyttää ainoastaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"nimiparametreja"}]},{"type":"text","value":", koska arvo- ja viiteparametrit ovat käsitteinä olemassa ainoastaan suoritusaikana."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kukin makro pitää määritellä ennen sen käyttöä. Esimerkiksi, luvussa 6 esitelty makro Swap määritellään seuraavanalaisesti."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"macro Swap (i, j)  -- vaihda i:n ja j:n arvot keskenään\ntmp = i;\ni = j;\nj = tmp;"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Makroja laajennettaessa kukin muodollinen nimiparametri korvataan tekstuaalisesti sen käyttökerran vastaavalla merkkijonolla. Esimerkiksi, makron Swap() käyttö "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Swap(x, tbl[y])"}]},{"type":"text","value":" laajenisi koodiksi"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"tmp = x;\nx = tbl[y];\ntbl[y] = tmp;"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"mikä toimii suoritusaikana aivan oikein, vaihtaen muuttujan X ja taulukon alkion tbl[y] arvot keskenään."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Symbolisissa konekielissä on tyypillistä käyttää makroja esimerkiksi aliohjelmien prologien ja preludien toteutukseen. Esimerkiksi Luvussa 6 esitetyn funktion fA(x,y) preludin voisi toteuttaa makrolla"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"-- funktion prelude, 2 parametria, 1 paikallinen muuttuja\nmacro Prelude-f-2-1 (fnimi, ret, par1, par2, loc1, loc1val)\nret equ -4\npar1 equ -3\npar2 equ -2\nloc1 equ 1\n\nfnimi push sp, 0\n      pushr sp\n      load r1, =loc1val\n      store r1, loc1(fp)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Nyt funktion fa() koodi olisi"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"    Prelude-f-2-1 (fa, retfA, parX, parY, locZ, 5)\n\n    ...                -- funktion varsinainen koodi\n\nf10 Epilog-f-2-1 ()  -- 2 parametria, 1 paik. muuttuja"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Makron "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Epilog-f-2-1()"}]},{"type":"text","value":" määrittely jätetään harjoitustehtäväksi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tässä esimerkissä makro Prelude-f-2-1() on vähän kompelö, koska sen käyttö sopii vain funktioille, joilla on kaksi parametria ja yksi paikallinen muuttuja. Hyvä ohjelmoija kirjoittaisi käyttökelpoisempia makroja, jos vain käytettävissä oleva makrojen määrittelykieli sen sallisi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Makroilla on muutama tärkeä ominaisuus verrattuna aliohjelmiin. Mainitsimmekin jo, että makrot siis lajennetaan koodiksi ennen käännöstä, kun taas aliohjelmia kutsutaan suoritusaikana. Koska jokainen makron käyttökerta laajenee aina koodiksi, niin 100 kappaletta 50-rivisen makron käyttökertaa laajenee 5000 riviksi koodia. Jos 50-rivistä aliohjelmaa kutsutaan 100 kertaa, niin koodin määrä on vain yhden aliohjelman toteutuksen n. 60 riviä. Lisäksi jokaisen kutsukerran toteutus on ehkä 10 riviä, joten yhteistarve on noin 60+100*10 = 1060 riviä koodia. Toisaalta makrosta generoitu koodi on paikallaan sellaisenaan, eikä vaadi kontrollin siirtoa suoritusaikana. Aliohjelman yhteydessä jokainen kontrollin siirto vaatii esim. 10-15 konekäskyn suorituksen aktivaatiotietuetta rakennettaessa tai purettaessa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Makrojen merkittävä ero aliohjelmiin on, että makroilla ei ole omaa viiteympäristöä, koska makrot laajennetaan sellaisenaan käyttökohtiinsa. Aliohjelmilla voidaan toteuttaa korkean tason kielten erilaiset viiteympäristöt. Esimerkiksi C-kielessä kussakin aliohjelmassa voi viitata sen omiin paikallisiin tietorakenteisiin ja globaaleihin kaikkialla viitattaviin tietorakenteisiin, mutta ei minkään muun aliohjelman paikallisiin tietorakenteisiin. Kullakin ohjelmointikielellä on omat määrittelynsä siitä, mikä on kunkin tunnuksen näkyvyysalue (käyttöalue) ja tunnusten näkyvyysalueet toteutetaan aktivaatiotietueiden avulla."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Assembler kääntäminen"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Symbolisen konekielen käännös tapahtuu periaatteessa kolmessa eri vaiheessa, mutta joskus näitä vaiheita voi yhdistellä. Kussakin vaiheessa käydään läpi koko käännösyksikkö alusta loppuun. Ensimmäisessä vaiheessa lasketaan kunkin konekäskyn vievä tila, generoidaan symbolitaulu ja uudelleensijoitustaulu. Ttk-91 koneessa tämä on helppoa, koska kukin konekäsky on saman mittainen (4 tavua), mutta esimerkiksi Intelin x86 arkkitehtuurin käskyt voivat olla 1-21 tavun mittaisia. Kun koodin (ja datan) pituus tiedetään, on helppo päätellä koodiin ja dataan viittavien symbolien arvot. Ensimmäisen vaiheen jälkeen symbolitauluun on saatu tieto kaikkien tämän moduulin symbolien arvoista."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Ensimmäisen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                  Data/koodi  Symb.taulu\nx \tdc \t13           -->  ?:           13        x: ?\ny \tdc \t15           -->  ?:           15        y: ?\n\nst   in   r1, =kbd   -->  0:   3 1 0 0   1      st: 0\n     jzer r1, done   -->  1:  34 1 0 0   ?    done: ?\n     out r1, =crt    -->  2:   4 1 0 0   0\n     jump st         -->  3:  32 0 0 0   0\ndone svc sp,=halt    -->  4: 112 6 0 0  11    done: 4\n                                                 x: 5\n                                                 y: 6"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Huomaa, että symboli "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"done"}]},{"type":"text","value":" esitellään jzer-käskyn yhteydessä, mutta sen arvoa ei vielä tunneta. Viimeisen käskyn kohdalla tunnus "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"done"}]},{"type":"text","value":" esiintyy osoitekentässä, joten sen arvo 4 saadaan selville. Muuttujat x ja y esitellään heti alussa, mutta niiden sijainnit (symbolien x ja y arvot) tiedetään vasta kun koodisegmentin koko (5 sanaa) tunnetaan. Muuttujat x ja y ovat mukana vain esimerkin vuoksi, eikä niihin viitata lyhyessä koodissa. Yhden läpikäynnin jälkeen kaikilla tämän moduulin sisäisillä tunnuksilla on arvo."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toisella läpikäynnillä koodi käydään uudestaan läpi konekäsky kerrallaan ja kaikki ensimmäisellä kerralla tuntemattomaksi jääneet tunnukset korvataan niiden arvolla symbolitaulusta. Koodissa voi tietenkin olla vielä viittauksia muihin moduuleihin, mutta ne ratkotaan vasta linkityksessä. Koodin käskyt voivat tässä vaiheessa olla vielä kentittäin koodattuna, eivätkä välttämättä vielä lopullisessa muodossaan konekäskynä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Toisen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                  Data/koodi  Symb.taulu\nx \tdc \t13           -->  5:            13       x: 5\ny \tdc \t15           -->  6:            15       y: 6\n\nst   in   r1, =kbd   -->  0:   3 1 0 0   1      st: 0\n     jzer r1, done   -->  1:  34 1 0 0   4    done: 4\n     out r1, =crt    -->  2:   4 1 0 0   0     ...\n     jump st         -->  3:  32 0 0 0   0\ndone svc sp,=halt    -->  4: 112 6 0 0  11"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kolmannella läpikäynnillä luodaan varsinainen konekielinen koodi yhdistelemällä kentät ja ehkä samalla optimoimalla koodia suoritusajan suhteen. Yleensä symbolisella konekielellä kirjoitettua ei juurikaan enää optimoida, koska ohjelmoija on nimenomaan halunnut kirjoittaa kyseisen ohjelman osan symbolisella konekielellä annetussa muodossa. Todellisen suorittimen optimoidun konekielisen koodin kirjoittaminen on vaikeata, koska siinä pitää ottaa huomioon kyseessä olevan suorittimen, väylän ja muistin yksityiskohdat. Optimoinnissa täytyy esimerkiksi ottaa huomioon, kuinka kauan aikaa menee datan hakemiseen muistista, jotta data on saatavilla seuraavissa konekäskyissä ilman odotusta. Korkean tason kielten kääntäjien tekijät ovat tässä asiantuntijoita ja sen vuoksi korkean tason kielten kääntäjien tekemää koodia on (nykyään) vaikea tavallisen ohjelmoijan tehdä nopeammaksi."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Kolmannen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                Data/koodi   Symb.taulu\nx \tdc \t13            -->  5:         13       x:  5\ny \tdc \t15            -->  6:         15       y:  6\n\nst   in   r1, =kbd    -->  0:   52428801      st:  0\n     jzer r1, done    -->  1:  572522500    done:  4\n     out r1, =crt     -->  2:   69206016    add:  17\n     jump st          -->  3:  536870912    scv: 112\ndone svc sp,=halt     -->  4: 1891631115    ..."}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Korkean tason kielen kääntäminen"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Korkean tason kielen (Java, C, Pascal, Fortran, etc) kääntämisessä on useampi vaihe. Ensimmäisessä vaiheessa koodista etsitään kaikki sen kyseisen ohjelmointikielen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"syntaktiset alkiot"}]},{"type":"text","value":" (kieliopilliset elementit). Tällaisia ovat esimerkiksi C-kielisen ohjelman"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"#include <stdio.h>\n\nint main(void)\n{\n    int x,\n\n    x = 234;\n    printf(\"%d\\n\", x);\n}"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ohjelmointikielen varatut sanat \"include\", \"int\", \"main\", \"void\" ja \"printf\". Niitä ovat myös kielen syntaktiset (kieliopilliset) merkit '#', '<', '>', '=', '(', ')', ';', '{' ja '}'. Lisäksi sieltä löytyy muuttujan nimi \"x\", kokonaisluku \"234\" sekä merkkijonot \"stdio\" ja \"%d\\n\"."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Näiden syntaktisten alkioiden avulla luodaan symbolitaulu. Kääntäjän "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"jäsentäjä"}]},{"type":"text","value":" tunnistaa ohjelmointikielen lauseet ja muut rakenteet yrittämällä sovittaa ne ohjelmointikielen määrittelyn mukaiseen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"syntaksipuuhun"}]},{"type":"text","value":". Jos rakenne on oikein, jäsentelijä voi generoida ohjelman syntaksipuuta vastaavan konekielisen koodin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Useissa ohjelmointikielten kääntäjissä (esim. Pascal, Java) jäsentäjä generoi konekielisen koodin asemesta ns. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"välikieliesityksen"}]},{"type":"text","value":", mikä on hypoteettisen tietokoneen konekieltä. Tällaista välikieliesitystä on jatkossa joustavampi käsitellä. Ensimmäisiä välikieliä oli Pascal-kielen "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/P-code_machine","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"P-code"}]},{"type":"text","value":". Java-kielen välikieliesitys on nimeltään "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Java_bytecode","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"bytecode"}]},{"type":"text","value":". Käsittelemme sitä lisää viimeisessä luvussa 10."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Microsoftin ohjelmistoympäristön "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"C#-kielen"}]},{"type":"text","value":" välikieliesitys "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Common_Intermediate_Language","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"CIL"}]},{"type":"text","value":" on tavallinen tapa toteuttaa niin C#-kielen kuin muidenkin samassa ohjelmointiympäristössä käytettävien ohjelmointikielten kääntäjä. Niistä kaikista generoidaan CIL-moduuleja, joita jatkossa käsitellään kaikkia samalla tavalla. Tämä on mielenkiintoinen lähestymistapa, koska se korvaa objektimoduulin käytön eri ohjelmointikielten yhdistävänä tekijänä. Objektimoduuli on sidoksissa jonkin tietyn suorittimen käskykantaan, kun taas CIL (ja bytecode) ovat geneerisiä ja sopivat yhtä hyvin (tai huonosti) kaikille suorittimille."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Välikielestä generoidaan konekielinen koodi. Koodin generoinnista kääntäjän viimeisenä vaiheena käytetään myös nimitystä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"back end"}]},{"type":"text","value":". Jos jo olemassa olevan ohjelmointikielen kääntäjästä halutaan uudelle suorittimelle sopiva versio, niin ainoastaan kääntäjän "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"back end"}]},{"type":"text","value":" tarvitsee ohjelmoida uudelleen. Se on ainoa kääntäjän osa, joka on sidoksissa suorittimen konekieleen. Vastaavasti kääntäjän osia syntaktisten alkioiden etsinnästä välikielisen koodin generointiin kutsutaan yhteisnimellä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"front end"}]},{"type":"text","value":". Kun haluamme toteuttaa kääntäjän uudelle ohjelmointikielelle, niin riittää toteuttaa uusi "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"front end"}]},{"type":"text","value":". Muut kääntäjän osat (niiden "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"back end"}]},{"type":"text","value":") ovat jo valmiina eri suorittimille."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Koodin optimointi"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koodin optimointi on vaikeata ja voi kestää hyvin kauan sen mukaan, miten tehokkaasti koodia halutaan optimoida. Osan optimoinnista voi tehdä jo välikielen tasolla, mutta pääosa tehdään koodin generoinnin yhteydessä. Optimoidun koodin generoimiseen voi kulua monta kertaa niin paljon aikaa kuin ilman optimointia. Tämän vuoksi ohjelmistojen kehityksessä ohjelmat koodataan ja testataan ensin valmiiksi optimoimattomalla koodilla ja sitten lopuksi käännetään maksimioptimoinnilla ennen käyttöönottoa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Rekistereiden allokointiongelma"}]},{"type":"text","value":" on tärkeä osa optimointia. Sen avulla päätellään, milloin ja mihin laiterekisteriin mitäkin dataa tulisi ohjelman suoritusaikana tallettaa. Rekistereitä on vähän ja niiden optimaalinen käyttö on tärkeätä. Esimerkiksi pitää päättää, pidetäänkö jonkin silmukan muuntelumuuttujan arvoa silmukan suorituksen aikana muistissa vai jossakin tietyssä rekisterissä (esim. r3), tai varataanko jokin rekisteri (esim. r5) koko moduulin suorituksen ajaksi usein päivitettävälle globaalille muuttujalle X."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Samoin pohditaan, minkälaisilla konekäskyillä jokin tietty koodinpätkä olisi nopeinta suorittaa, tai voisiko jotkut konekäskyt jättää kokonaan pois. Tällainen päättely ei ole ihan helppoa. Ongelman tekee vielä vaativammaksi se, että nykyisissä todellisissa suorittimissa voi useaa (eri tyyppistä?) konekäskyä oikeasti suorittaa samanaikaisesti. Monen samaan aikaan suoritettavan konekäskyvirran optimointi on vielä vaativampaa kuin yhden."}]}]},"html":"<div><div>\n<lead>Tässä aliluvussa esittelemme pääpiirteet, joilla käännösyksikkö käännetään objektimoduuliksi.</lead>\n</div><h2>Objektimoduulin rakenne</h2><p>Käännöksessä luodaan objektimoduuli, joka myöhemmin linkitetään muihin objektimoduuleihin. Objektimoduulissa on kolme tärkeätä tietorakennetta: konekielinen ohjelmakoodi, linkityksen tarvitsemat tiedot <em>uudelleensijoitustaulussa</em> ja kaikki ohjelman käytämät symbolit ja niiden arvot <em>symbolitaulussa</em>. Symbolitaulu voi olla irrallinen tietorakenne tai sitten se on osa uudelleensijoitustaulua.</p><p>Objektimoduulissa on koodi konekielisessä muodossa ja kaikki moduulin sisäiset viitteet jo oikein, mutta vain tämän objektimoduulin omassa (pienehkössä) osoiteavaruudessa.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">käännösyksikkö             osoite  data tai konekäskyn kentät\n                                         opcode Rj Ri M Addr\nx     dc 5             --&gt;     0:                        5\ny     dc 7             --&gt;     1:                        7\n      load r1, x       --&gt;     2:           2  1  0 1    0 *\n      add  r1, y       --&gt;     3:          17  1  0 1    1 *\n      ...\n      call sp, matmul  --&gt;    34:          49  6  0 1    0 *\n      ...\naver  pushr sp         --&gt;    77:          53  6  0 0    0 *\n      ...\n\n      svc  sp, =halt   --&gt;   323:          112 6  0 0   11</code></pre></div><p>Objektimoduulissa pitää jollain tavoin merkitä sellaisten viitteet <em>moduulin sisäisiin osoitteisiin</em> sen omassa muistiavaruudessa, koska nämä pitää päivittää linkityksen yhteydessä. Ylläolevassa esimerkissä viitteet muuttujiin x (osoite 0) ja y (osoite 1) ovat tällaisia. Yleisesti ottaen linkityksen aikana päivitettävien osoitteiden sijainnit pidetään kääntäjän luomassa uudelleensijoitustaulussa.</p><p>Objektimoduulissa voi olla myös viitteitä dataan tai koodiin muissa moduuleissa. Ylläolevassa esimerkissä muistipaikassa 34 on kutsu jossakin toisessa moduulissa olevaan aliohjelmaan <em>matmul</em>, jonka osoitetta ei ole lainkaan vielä tiedossa. Sitten kun tieto linkityksen yhteydessä löytyy, se pitää laittaa paikalleen tämän moduuliin koodiin. Myös tällaisten linkityksen aikana päivitettävien  <em>moduulin ulkopuolisten osoitteiden</em> sijainnit ovat em. uudelleensijoitustaulussa, sen <em>IMPORT</em>-osiossa (import-taulussa).</p><p>Lisäksi uudelleensijoitustaulussa on vielä <em>EXPORT</em>-osio (export-taulu), jossa on tieto niistä data- tai koodiosoitteista, joihin saa tässä moduulissa viitata <em>muista moduuleista</em>. Ylläolevassa esimerkissä esimerkiksi funktio <em>aver</em> osoitteessa 77 voisi olla tällainen muiden moduulien kutsuttavissa oleva rutiini.</p><h3>Symbolitaulu</h3><p>Symbolitaulussa on siis kaikki ohjelman käyttämät symbolit ja niiden arvot. Joidenkin symbolien arvot annetaan, joidenkin arvot päätellään käännösmoduulista käännösvaiheessa, joidenkin arvot selviävät linkitysvaiheessa ja joidenkin vasta suoritusaikana.</p><p>Kussakin (korkean tason ja symbolisen konekielen) ohjelmointikielessä on  merkittävä joukko etukäteen määriteltyjä symboleja, joiden arvot löytyvät myös symbolitaulusta. Tällaisia ovat esimerkiksi symbolisen konekielen operaatiokoodien nimet (add, comp, jump, etc), laiterekisterien nimet (r0, r4, sp, etc), laitteiden nimet (crt, kbd, etc) ja käyttöjärjestelmäpalvelujen nimet (halt, time, etc).</p><p>Esimerkiksi symbolisen konekielen equ-valekäskyllä määritellään jollekin symbolille arvo ja se talletetaan symbolitauluun. Moduulin omien tietorakenteiden sijainnit ja niitä vastaavien symbolien arvot määräytyvät täysin siitä, missä järjestyksessä ne on kirjoitettu käännösyksikön ohjelmakoodiin. Ihan vastaavasti kaikki koodissa olevat käskyjen osoitteet määräytyvät niiden tekstuaalisen sijainnin perusteella käännösyksikössä.</p><p>Kun moduulissa viitataan moduuliin ulkopuoliseen dataan tai koodiin, niin niitä vastaavien symbolien arvot selviävät vasta linkitysvaiheessa. Dynaamisesti linkitettävien moduulien osalta symbolien arvot tarkentuvat vasta suoritusaikana.</p><p>Jos dynaamista linkitystä ei ole käytössä, niin koko symbolitaulun voi jättää pois latausmoduulista. Kaikilla symboleilla  on jo arvot ja ne on päivitetty koodiin. Usein symbolitaulu pidetään kuitenkin tallessa ainakin ohjelmiston kehitysaikana, jotta sen avulla voidaan tehdä järkevämpiä virheilmoituksia. Ohjelmoijalle on paljon mukavampaa lukea \"Integer overflow for variable X in line 4226 in module Statistics\" kuin \"Integer overflow in 0x00004321\". Toisaalta taas älykellon käyttäjä ei missään tapauksessa halua nähdä kumpaakaan noista ilmoituksista ja symbolitaulun vaatiman muistitilan voi käyttää paremminkin.</p><h3>Literaalit</h3><p>Literaali tarkoittaa ohjelmassa olevia vakioita. Ne on usein sijoitettu omalle muistialueelleen, eikä tällaisella <em>literaalialueella</em> olevia arvoja saisi muuttaa. On ilmeisen virhealtista muuttaa literaalin Sata arvoksi 101, jne. Esimerkkikonekielessä ttk-91 kaikki vakiot ovat literaaleja, mutta niiden muuttamattomuutta valvotaan vain ohjelmointikurilla. Useissa järjestelmissä vakiot talletetaan omalle suojatulle muistisegmentille. Siellä olevia tietoja voi lukea ja niitä voi lisätä, mutta tietoja ei voi muuttaa.</p><p>Joissakin kielissä kaikki merkkijonot ovat literaaleja. Joissakin kielissä kaikki koodissa olevat isot vakiot ovat literaaleja, jolloin ison vakion käyttäminen koodissa automaattisesti johtaa uuden vakion määrittelyyn.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">load r2, &quot;mystring&quot; --&gt;  Lmystring ds &quot;mystring&quot; ; ei ttk-92:ssä\n                                   load r2, =Lmystring ; merkkijonon osoite\n\nload r1, =800000    --&gt;  L800000 dc 800000\n                                 load r1, L800000   ; viittaus muistiin, ei käskyn vakio-osaan</code></pre></div><p>Literaalia ei saisi välittää viiteparametrina, koska tällöin kutsuttu rutiini voisi (vahingossa) muuttaa sen arvoa. Useissa kielissä esimerkiksi kaikki merkkijonot välitetään joka tapauksessa viiteparametreina. Arvon muutoksen voi kuitenkin estää, jos literaalit on talletettu suojatulle literaalialueelle.</p><p>Joissakin kielissä kaikki koodissa olevat vakiot ovat literaaleja. Tämä tekee vakioiden käsittelystä linjakasta, mutta toisaalta pienten vakioiden talletus literaalialueelle hidastaa suoritusta verrattuna tilanteeseen, jossa ne talletettaisiin käskyjen vakiokenttiin.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">load    r1,=5    --&gt;    L5  dc 5\n                        load r1, L5</code></pre></div><p>Jos literaalin arvoja voisi muuttaa, niin myös seuraava koodinpätkä olisi mahdollinen.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">load    r1, =5    --&gt;    L5  dc 5\n                         load r1, L5\nstore   r1, =6    --&gt;    L6  dc 6\n                         store r1, L6</code></pre></div><p>Ohjelmointikuri on selvästi pettänyt ja vakion L6 arvo on nyt 5, mistä seuraisi jatkossa luultavasti hyvin paljon ongelmia.  Joissakin (vanhemmissa) kielissä oli mahdollista kirjoittaa lause \"6=5;\", millä oli juuri sama lopputulos. Nykyisissä kielissä tämä ei ole mahdollista, koska ensinnäkin kielen määrittely estää sen ja toiseksi literaalit sijaitsevat suojatulla muistialueella.</p><h3>Makrot</h3><p>Useissa korkean tason kielissä ja symbolisissa konekielissä on mahdollisuus käyttää <em>makroja</em>. Makrot ovat usein toistettavia koodisarjoja ja niiden käyttö helpottaa ohjelmointia. Niissä voi olla parametreja, minkä vuoksi ne voi joskus sekoittaa aliohjelmiin vaikka ne ovat täysin erilaisia.</p><p>Makrot käsitellään ennen kääntämistä. Ennen varsinaista käännöstä koko ohjelmakoodi käydään läpi ja kukin makro <em>laajennetaan</em> tekstuaalisesti sitä vastaavaksi koodinpätkäksi. Tämän vuoksi makroissa voi käyttää ainoastaan <em>nimiparametreja</em>, koska arvo- ja viiteparametrit ovat käsitteinä olemassa ainoastaan suoritusaikana.</p><p>Kukin makro pitää määritellä ennen sen käyttöä. Esimerkiksi, luvussa 6 esitelty makro Swap määritellään seuraavanalaisesti.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">macro Swap (i, j)  -- vaihda i:n ja j:n arvot keskenään\ntmp = i;\ni = j;\nj = tmp;</code></pre></div><p>Makroja laajennettaessa kukin muodollinen nimiparametri korvataan tekstuaalisesti sen käyttökerran vastaavalla merkkijonolla. Esimerkiksi, makron Swap() käyttö <em>Swap(x, tbl[y])</em> laajenisi koodiksi</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tmp = x;\nx = tbl[y];\ntbl[y] = tmp;</code></pre></div><p>mikä toimii suoritusaikana aivan oikein, vaihtaen muuttujan X ja taulukon alkion tbl[y] arvot keskenään.</p><p>Symbolisissa konekielissä on tyypillistä käyttää makroja esimerkiksi aliohjelmien prologien ja preludien toteutukseen. Esimerkiksi Luvussa 6 esitetyn funktion fA(x,y) preludin voisi toteuttaa makrolla</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- funktion prelude, 2 parametria, 1 paikallinen muuttuja\nmacro Prelude-f-2-1 (fnimi, ret, par1, par2, loc1, loc1val)\nret equ -4\npar1 equ -3\npar2 equ -2\nloc1 equ 1\n\nfnimi push sp, 0\n      pushr sp\n      load r1, =loc1val\n      store r1, loc1(fp)</code></pre></div><p>Nyt funktion fa() koodi olisi</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    Prelude-f-2-1 (fa, retfA, parX, parY, locZ, 5)\n\n    ...                -- funktion varsinainen koodi\n\nf10 Epilog-f-2-1 ()  -- 2 parametria, 1 paik. muuttuja</code></pre></div><p>Makron <em>Epilog-f-2-1()</em> määrittely jätetään harjoitustehtäväksi.</p><p>Tässä esimerkissä makro Prelude-f-2-1() on vähän kompelö, koska sen käyttö sopii vain funktioille, joilla on kaksi parametria ja yksi paikallinen muuttuja. Hyvä ohjelmoija kirjoittaisi käyttökelpoisempia makroja, jos vain käytettävissä oleva makrojen määrittelykieli sen sallisi.</p><p>Makroilla on muutama tärkeä ominaisuus verrattuna aliohjelmiin. Mainitsimmekin jo, että makrot siis lajennetaan koodiksi ennen käännöstä, kun taas aliohjelmia kutsutaan suoritusaikana. Koska jokainen makron käyttökerta laajenee aina koodiksi, niin 100 kappaletta 50-rivisen makron käyttökertaa laajenee 5000 riviksi koodia. Jos 50-rivistä aliohjelmaa kutsutaan 100 kertaa, niin koodin määrä on vain yhden aliohjelman toteutuksen n. 60 riviä. Lisäksi jokaisen kutsukerran toteutus on ehkä 10 riviä, joten yhteistarve on noin 60+100*10 = 1060 riviä koodia. Toisaalta makrosta generoitu koodi on paikallaan sellaisenaan, eikä vaadi kontrollin siirtoa suoritusaikana. Aliohjelman yhteydessä jokainen kontrollin siirto vaatii esim. 10-15 konekäskyn suorituksen aktivaatiotietuetta rakennettaessa tai purettaessa.</p><p>Makrojen merkittävä ero aliohjelmiin on, että makroilla ei ole omaa viiteympäristöä, koska makrot laajennetaan sellaisenaan käyttökohtiinsa. Aliohjelmilla voidaan toteuttaa korkean tason kielten erilaiset viiteympäristöt. Esimerkiksi C-kielessä kussakin aliohjelmassa voi viitata sen omiin paikallisiin tietorakenteisiin ja globaaleihin kaikkialla viitattaviin tietorakenteisiin, mutta ei minkään muun aliohjelman paikallisiin tietorakenteisiin. Kullakin ohjelmointikielellä on omat määrittelynsä siitä, mikä on kunkin tunnuksen näkyvyysalue (käyttöalue) ja tunnusten näkyvyysalueet toteutetaan aktivaatiotietueiden avulla.</p><h2>Assembler kääntäminen</h2><p>Symbolisen konekielen käännös tapahtuu periaatteessa kolmessa eri vaiheessa, mutta joskus näitä vaiheita voi yhdistellä. Kussakin vaiheessa käydään läpi koko käännösyksikkö alusta loppuun. Ensimmäisessä vaiheessa lasketaan kunkin konekäskyn vievä tila, generoidaan symbolitaulu ja uudelleensijoitustaulu. Ttk-91 koneessa tämä on helppoa, koska kukin konekäsky on saman mittainen (4 tavua), mutta esimerkiksi Intelin x86 arkkitehtuurin käskyt voivat olla 1-21 tavun mittaisia. Kun koodin (ja datan) pituus tiedetään, on helppo päätellä koodiin ja dataan viittavien symbolien arvot. Ensimmäisen vaiheen jälkeen symbolitauluun on saatu tieto kaikkien tämän moduulin symbolien arvoista.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ensimmäisen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                  Data/koodi  Symb.taulu\nx \tdc \t13           --&gt;  ?:           13        x: ?\ny \tdc \t15           --&gt;  ?:           15        y: ?\n\nst   in   r1, =kbd   --&gt;  0:   3 1 0 0   1      st: 0\n     jzer r1, done   --&gt;  1:  34 1 0 0   ?    done: ?\n     out r1, =crt    --&gt;  2:   4 1 0 0   0\n     jump st         --&gt;  3:  32 0 0 0   0\ndone svc sp,=halt    --&gt;  4: 112 6 0 0  11    done: 4\n                                                 x: 5\n                                                 y: 6</code></pre></div><p>Huomaa, että symboli <em>done</em> esitellään jzer-käskyn yhteydessä, mutta sen arvoa ei vielä tunneta. Viimeisen käskyn kohdalla tunnus <em>done</em> esiintyy osoitekentässä, joten sen arvo 4 saadaan selville. Muuttujat x ja y esitellään heti alussa, mutta niiden sijainnit (symbolien x ja y arvot) tiedetään vasta kun koodisegmentin koko (5 sanaa) tunnetaan. Muuttujat x ja y ovat mukana vain esimerkin vuoksi, eikä niihin viitata lyhyessä koodissa. Yhden läpikäynnin jälkeen kaikilla tämän moduulin sisäisillä tunnuksilla on arvo.</p><p>Toisella läpikäynnillä koodi käydään uudestaan läpi konekäsky kerrallaan ja kaikki ensimmäisellä kerralla tuntemattomaksi jääneet tunnukset korvataan niiden arvolla symbolitaulusta. Koodissa voi tietenkin olla vielä viittauksia muihin moduuleihin, mutta ne ratkotaan vasta linkityksessä. Koodin käskyt voivat tässä vaiheessa olla vielä kentittäin koodattuna, eivätkä välttämättä vielä lopullisessa muodossaan konekäskynä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Toisen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                  Data/koodi  Symb.taulu\nx \tdc \t13           --&gt;  5:            13       x: 5\ny \tdc \t15           --&gt;  6:            15       y: 6\n\nst   in   r1, =kbd   --&gt;  0:   3 1 0 0   1      st: 0\n     jzer r1, done   --&gt;  1:  34 1 0 0   4    done: 4\n     out r1, =crt    --&gt;  2:   4 1 0 0   0     ...\n     jump st         --&gt;  3:  32 0 0 0   0\ndone svc sp,=halt    --&gt;  4: 112 6 0 0  11</code></pre></div><p>Kolmannella läpikäynnillä luodaan varsinainen konekielinen koodi yhdistelemällä kentät ja ehkä samalla optimoimalla koodia suoritusajan suhteen. Yleensä symbolisella konekielellä kirjoitettua ei juurikaan enää optimoida, koska ohjelmoija on nimenomaan halunnut kirjoittaa kyseisen ohjelman osan symbolisella konekielellä annetussa muodossa. Todellisen suorittimen optimoidun konekielisen koodin kirjoittaminen on vaikeata, koska siinä pitää ottaa huomioon kyseessä olevan suorittimen, väylän ja muistin yksityiskohdat. Optimoinnissa täytyy esimerkiksi ottaa huomioon, kuinka kauan aikaa menee datan hakemiseen muistista, jotta data on saatavilla seuraavissa konekäskyissä ilman odotusta. Korkean tason kielten kääntäjien tekijät ovat tässä asiantuntijoita ja sen vuoksi korkean tason kielten kääntäjien tekemää koodia on (nykyään) vaikea tavallisen ohjelmoijan tehdä nopeammaksi.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Kolmannen vaiheen (koodin läpikäynnin) jälkeen.\nKäännösyksikkö                Data/koodi   Symb.taulu\nx \tdc \t13            --&gt;  5:         13       x:  5\ny \tdc \t15            --&gt;  6:         15       y:  6\n\nst   in   r1, =kbd    --&gt;  0:   52428801      st:  0\n     jzer r1, done    --&gt;  1:  572522500    done:  4\n     out r1, =crt     --&gt;  2:   69206016    add:  17\n     jump st          --&gt;  3:  536870912    scv: 112\ndone svc sp,=halt     --&gt;  4: 1891631115    ...</code></pre></div><h2>Korkean tason kielen kääntäminen</h2><p>Korkean tason kielen (Java, C, Pascal, Fortran, etc) kääntämisessä on useampi vaihe. Ensimmäisessä vaiheessa koodista etsitään kaikki sen kyseisen ohjelmointikielen <em>syntaktiset alkiot</em> (kieliopilliset elementit). Tällaisia ovat esimerkiksi C-kielisen ohjelman</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x,\n\n    x = 234;\n    printf(&quot;%d\\n&quot;, x);\n}</code></pre></div><p>ohjelmointikielen varatut sanat \"include\", \"int\", \"main\", \"void\" ja \"printf\". Niitä ovat myös kielen syntaktiset (kieliopilliset) merkit '#', '&#x3C;', '>', '=', '(', ')', ';', '{' ja '}'. Lisäksi sieltä löytyy muuttujan nimi \"x\", kokonaisluku \"234\" sekä merkkijonot \"stdio\" ja \"%d\\n\".</p><p>Näiden syntaktisten alkioiden avulla luodaan symbolitaulu. Kääntäjän <em>jäsentäjä</em> tunnistaa ohjelmointikielen lauseet ja muut rakenteet yrittämällä sovittaa ne ohjelmointikielen määrittelyn mukaiseen <em>syntaksipuuhun</em>. Jos rakenne on oikein, jäsentelijä voi generoida ohjelman syntaksipuuta vastaavan konekielisen koodin.</p><p>Useissa ohjelmointikielten kääntäjissä (esim. Pascal, Java) jäsentäjä generoi konekielisen koodin asemesta ns. <em>välikieliesityksen</em>, mikä on hypoteettisen tietokoneen konekieltä. Tällaista välikieliesitystä on jatkossa joustavampi käsitellä. Ensimmäisiä välikieliä oli Pascal-kielen <a href=\"https://en.wikipedia.org/wiki/P-code_machine\" target=\"_blank\" rel=\"noopener noreferrer\">P-code</a>. Java-kielen välikieliesitys on nimeltään <a href=\"https://en.wikipedia.org/wiki/Java_bytecode\" target=\"_blank\" rel=\"noopener noreferrer\">bytecode</a>. Käsittelemme sitä lisää viimeisessä luvussa 10.</p><p>Microsoftin ohjelmistoympäristön <a href=\"https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29\" target=\"_blank\" rel=\"noopener noreferrer\">C#-kielen</a> välikieliesitys <a href=\"https://en.wikipedia.org/wiki/Common_Intermediate_Language\" target=\"_blank\" rel=\"noopener noreferrer\">CIL</a> on tavallinen tapa toteuttaa niin C#-kielen kuin muidenkin samassa ohjelmointiympäristössä käytettävien ohjelmointikielten kääntäjä. Niistä kaikista generoidaan CIL-moduuleja, joita jatkossa käsitellään kaikkia samalla tavalla. Tämä on mielenkiintoinen lähestymistapa, koska se korvaa objektimoduulin käytön eri ohjelmointikielten yhdistävänä tekijänä. Objektimoduuli on sidoksissa jonkin tietyn suorittimen käskykantaan, kun taas CIL (ja bytecode) ovat geneerisiä ja sopivat yhtä hyvin (tai huonosti) kaikille suorittimille.</p><p>Välikielestä generoidaan konekielinen koodi. Koodin generoinnista kääntäjän viimeisenä vaiheena käytetään myös nimitystä <em>back end</em>. Jos jo olemassa olevan ohjelmointikielen kääntäjästä halutaan uudelle suorittimelle sopiva versio, niin ainoastaan kääntäjän <em>back end</em> tarvitsee ohjelmoida uudelleen. Se on ainoa kääntäjän osa, joka on sidoksissa suorittimen konekieleen. Vastaavasti kääntäjän osia syntaktisten alkioiden etsinnästä välikielisen koodin generointiin kutsutaan yhteisnimellä <em>front end</em>. Kun haluamme toteuttaa kääntäjän uudelle ohjelmointikielelle, niin riittää toteuttaa uusi <em>front end</em>. Muut kääntäjän osat (niiden <em>back end</em>) ovat jo valmiina eri suorittimille.</p><h2>Koodin optimointi</h2><p>Koodin optimointi on vaikeata ja voi kestää hyvin kauan sen mukaan, miten tehokkaasti koodia halutaan optimoida. Osan optimoinnista voi tehdä jo välikielen tasolla, mutta pääosa tehdään koodin generoinnin yhteydessä. Optimoidun koodin generoimiseen voi kulua monta kertaa niin paljon aikaa kuin ilman optimointia. Tämän vuoksi ohjelmistojen kehityksessä ohjelmat koodataan ja testataan ensin valmiiksi optimoimattomalla koodilla ja sitten lopuksi käännetään maksimioptimoinnilla ennen käyttöönottoa.</p><p><em>Rekistereiden allokointiongelma</em> on tärkeä osa optimointia. Sen avulla päätellään, milloin ja mihin laiterekisteriin mitäkin dataa tulisi ohjelman suoritusaikana tallettaa. Rekistereitä on vähän ja niiden optimaalinen käyttö on tärkeätä. Esimerkiksi pitää päättää, pidetäänkö jonkin silmukan muuntelumuuttujan arvoa silmukan suorituksen aikana muistissa vai jossakin tietyssä rekisterissä (esim. r3), tai varataanko jokin rekisteri (esim. r5) koko moduulin suorituksen ajaksi usein päivitettävälle globaalille muuttujalle X.</p><p>Samoin pohditaan, minkälaisilla konekäskyillä jokin tietty koodinpätkä olisi nopeinta suorittaa, tai voisiko jotkut konekäskyt jättää kokonaan pois. Tällainen päättely ei ole ihan helppoa. Ongelman tekee vielä vaativammaksi se, että nykyisissä todellisissa suorittimissa voi useaa (eri tyyppistä?) konekäskyä oikeasti suorittaa samanaikaisesti. Monen samaan aikaan suoritettavan konekäskyvirran optimointi on vielä vaativampaa kuin yhden.</p></div>","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}},"allPages":{"edges":[{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}