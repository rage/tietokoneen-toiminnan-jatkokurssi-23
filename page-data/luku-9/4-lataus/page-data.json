{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-9/4-lataus","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Tässä aliluvussa kuvaamme, kuinka latausmoduulista saadaan järjestelmässä suorituskelpoinen prosessi.\n"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Latausmoduuli"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oletamme nyt, että latausmoduuli on staattisesti linkitetty moduuli, jonka voi sellaisenaan suorittaa. Esittelimme edellisessä aliluvussa dynaamisen linkityksen, emmekä käsittele sitä tässä sen enempää."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Latausmoduulissa on ohjelman koodi konekielisessä esitysmuodossa ja mistä konekäskystä pääohjelman suoritus alkaa. Siellä on määritelty tilanvaraukset kaikille globaaleille (pääohjelmatasolla) määritellyille tietorakenteille mahdollisine alkuarvoineen. Siellä on myös kerrottu, kuinka suuri pino tälle ohjelmalle tulee varata ja mitä tiedostoja täytyy avata ohjelman käynnistämisen yhteydessä."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lataus, prosessin luonti"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käyttöjärjestelmä (KJ) luo uuden prosessin valitsemalla ensin sille uuden prosessin tunnisteen (PID, process identifier). Prosessille varataan muistitilaa keskusmuistista sen koodia ja hallintotietoja varten. Jos käytössä on virtuaalimuisti, niin prosessille varataan muistitilaa virtuaalimuistin sivutauluille ja massamuistitilaa prosessin koko muistiavaruuden tallettamiseksi virtuaalimuistin tukimuistiin (ks. Luku 8)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"KJ luo prosessille sen kuvaajan (kontrollilohko, "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Process_control_block","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"PCB"}]},{"type":"text","value":", "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Process_control_block","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Process Control Block"}]},{"type":"text","value":"). Kuvaajassa on tallessa kaikki prosessin käyttämät resurssit (ks. Luku 4). Prosessille avataan sen tarvitsemat tiedostot, laitteet ja verkkoyhteydet joko tässä yhteydessä etukäteen tai vasta prosessin suorituksen aikana. Tiedot kaikista aukiolevista tiedostoista, laitteista ja verkkoyhteyksistä ovat myös kuvaajassa. Kuvaajat ovat usein vakiokokoisia ja KJ tallettaa ne omalle muistialueelleen. Kuvaajalle ei siten yleensä tarvitse varata muistitilaa, vaan ainoastaan otetaan joku vapaana oleva kuvaaja uusiokäyttöön. Kuvaaja on (tietenkin) KJ:n omalla muistialueelle ja siihen voi viitata ainoastaan etuoikeutetussa suoritustilassa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Prosessille varataan muistitilaa pinolle, keolle ja muiden prosessien kanssa yhteisille muistialueille sen latausmoduulissa annettujen määrittelyjen mukaisesti. Kaikki tiedot talletetaan kuvaajaan."}]},{"type":"comment","value":" kuva: ch-9-4-prosessi-pcb  "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/db1db146cf05c4a7d4faf013123a266e/ch-9-4-prosessi-pcb.svg","alt":"Otsake Prosessi ja sen kuvaaja (PCB). Oikealla on iso laatikko, joka kuvaa muistia. Siinä on prosessin muistialueet PC, koodi ja pino. Vasemmalla on PCB suurennettuna ja siinä ensin kentät PID ja suoritinympäristö (PC, etc). Sitten varatut muistialueet (pcp, koodi, pino), joista kustakin on nuoli oikealla olevaan muistin vastaavaan alueeseen. Lopuksi PCB.ssä on kentät tiedostot, laitteet, verkkoyhteydet, CPU-prioriteetti, jne.  Alla on väylän takana massamuistina kovalevy, josta on varattu tietty määrä tilaa virtuaalimuistin tukimuistille."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-9-4-prosessi-pcb"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Perusidea on, että "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kaikki"}]},{"type":"text","value":" yhteen prosessiin liittyvät tiedot löytyvät sen kuvaajasta (ja siihen linkitetyistä muista tietorakenteista). Sitten kun prosessi aikanaan poistetaan järjestelmästä, käyttöjärjestelmä voi kuvaajan tietojen perusteella vapauttaa kaikki prosessin käyttämät resurssit ja lopulta vapauttaa sen tunnisteen (PID) ja kuvaajan uusiokäyttöön."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Prosessin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"suoritinympäristössä"}]},{"type":"text","value":" (processor context) on arvot kaikille laiterekistereille, jotka pitää ladata, kun tämä prosessi aikanaan pääsee suoritukseen. Kun (jos) prosessi joutuu myöhemmin odottamaan mistä tahansa syystä, suoritinympäristö kopioidaan suorittimelta tänne sitä varten, että suoritus voisi joskus jatkua samasta kohtaa (samasta konekäskystä sen alusta pitäen) täsmälleen samassa ympäristössä kuin mitä se oli suorituksen keskeytyessä. Suoritinympäristöön kuuluvat kaikki rekisterit ja prosessin hallintaan liittyvät rekisterit em. tarkoitusta varten. Siihen sisältyvät esimerkiksi kaikki laskentaan tarvittavat työ- ja indeksirekisterit sekä erilaiset suorittimen kontrolliin liittyvät rekisterit, kuten paikanlaskuri PC, pinorekisteri SP, kekorekisteri HP, tilarekisteri SR, vertailujen tulosrekisterit CR, muistialueiden rajarekisterit BASE ja LIMIT, virtuaalimuistin sivutaulujen osoiterekisterit PT, jne."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Nyt prosessi on valmis ja järjestelmä tunnistaa sen uniikista PID:stä. Jos prosessin kaikki tarvittavat resurssit (esim. riittävä määrä keskusmuistia) on heti saatu käyttöön, prosessi voidaan siirtää R-to-R jonoon (valmis suoritukseen -jono, Ready-jono, Ready-to-Run-jono) odottamaan suoritusta suorittimella. Muussa tapauksessa prosessi laitetaan odotustilaan (esim. keskusmuistia odottavien prosessien jonoon), josta se sitten joskus myöhemmin resurssien vapauduttua pääsee R-to-R-jonoon odottamaan suoritusvuoroaan."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Prosessin kuvaajan tietoja ja prosessien hallintaa yleensä käsitellään tarkemmin yliopistojen käyttöjärjestelmäkursseilla."}]},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Historiaa: Ensimmäinen korkean tason kielen kääntäjä"},"children":[{"type":"text","value":"\nEnsimmäinen korkean tason kielen kääntäjä valmistui 1957 IBM:llä John Backuksen ryhmässä Fortran-kielelle IBM 704 -järjestelmälle. Fortrania on koko ajan kehitetty ajan mukaiseksi ja sitä voi nykyään käyttää niin lohkoperustaiseen ohjelmointiin kuin rinnakkaislaskentaa vaativiin tehtäviin. Ensimmäisen kääntäjän tekeminen kesti neljä vuotta. Kääntäjällä pystyi alusta pitäen tuottamaan optimoitua koodia, koska asiakkaat olivat tottuneet assemblerilla käsin koodattuun hyvin optimoituun koodiin."},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/25afa426c31b76e682a075b8f71be586/ch-9-4-ibm-704.svg","alt":"IBM 704 NACAn konesalissa 1957. NACA oli NASAn edeltäjä ja siitä tuli NASA 1958. Edessä on naispuolinen operaattori syöttämässä ohjelmaa reikäkortinlukijaan ja takana on miespuolinen insinööri tutkailemassa usean metrin mittaista ja puolitoista metriä korkeaa tietokonetta, josta etupaneelit on poistettu. Tietokoneen sisäinen langoitus on näkyvillä ja oikealla puolella on suuri noin 1m x 1m ohjauspaneeli."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-9-4-ibm-704"},"children":[]},{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Yhteenveto"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tässä luvussa annoimme yleiskuvan siitä, kuinka ns. \"tavallisella\" korkean tason kielellä kirjoitetusta ohjelmasta saadaan järjestelmässä suoritettava prosessi. Ohjelman esitysmuotona on järjestelmän suorittimen ymmärtämä konekieli, joka annetaan suorittimelle koodina. Käännösmoduuleista saadaan eri ohjelmointikielistä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kääntämällä"}]},{"type":"text","value":" kohdearkkitehtuurin konekielisiä objektimoduuleita. Niissä on kussakin uudelleensijoitustaulu, jonka avulla on määritelty liitokset kaikkiin muihin objektimoduuleihin. Objektimoduulit "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"linkitetään"}]},{"type":"text","value":" yhteen osoiteavaruuteen latausmoduuliksi, josta "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"lataaja"}]},{"type":"text","value":" sitten muodostaa käyttöjärjestelmän tunteman suorituskelpoisen prosessin. Eri ohjelmointikielten kääntäjät, staattiset ja dynaamiset linkittäjät sekä lataaja ovat normaaleja käyttöjärjestelmään sisältyviä peruspalikoita."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On myös olemassa toisen tyyppinen ohjelmien suoritustapa. Siinä suoritettava ohjelma annetaan datana (syötteenä) jollekin käyttöjärjestelmän tunnistamalle prosessille, joka voi olla esimerkiksi tulkki, emulaattori tai simulaattori. Suoritettavan ohjelman esitysmuoto voi olla esimerkiksi jotain skriptikieltä, jonkin toisen koneen konekieltä tai korkean tason kielen kääntäjän välikieltä. Tällaista ohjelmien suoritustapaa käsitellään seuraavassa luvussa 10."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vastaa alla olevaan kyselyyn, kun olet opiskellut tämän luvun asiat."}]},{"type":"comment","value":" ### summary quizit lukuun 9 ??? "},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"716f4349-3b44-54c0-921f-ce6bf474480e"},"children":[]}]}]},"html":"<div><div>\n<lead>Tässä aliluvussa kuvaamme, kuinka latausmoduulista saadaan järjestelmässä suorituskelpoinen prosessi.\n</lead>\n</div><h2>Latausmoduuli</h2><p>Oletamme nyt, että latausmoduuli on staattisesti linkitetty moduuli, jonka voi sellaisenaan suorittaa. Esittelimme edellisessä aliluvussa dynaamisen linkityksen, emmekä käsittele sitä tässä sen enempää.</p><p>Latausmoduulissa on ohjelman koodi konekielisessä esitysmuodossa ja mistä konekäskystä pääohjelman suoritus alkaa. Siellä on määritelty tilanvaraukset kaikille globaaleille (pääohjelmatasolla) määritellyille tietorakenteille mahdollisine alkuarvoineen. Siellä on myös kerrottu, kuinka suuri pino tälle ohjelmalle tulee varata ja mitä tiedostoja täytyy avata ohjelman käynnistämisen yhteydessä.</p><h2>Lataus, prosessin luonti</h2><p>Käyttöjärjestelmä (KJ) luo uuden prosessin valitsemalla ensin sille uuden prosessin tunnisteen (PID, process identifier). Prosessille varataan muistitilaa keskusmuistista sen koodia ja hallintotietoja varten. Jos käytössä on virtuaalimuisti, niin prosessille varataan muistitilaa virtuaalimuistin sivutauluille ja massamuistitilaa prosessin koko muistiavaruuden tallettamiseksi virtuaalimuistin tukimuistiin (ks. Luku 8).</p><p>KJ luo prosessille sen kuvaajan (kontrollilohko, <a href=\"https://en.wikipedia.org/wiki/Process_control_block\" target=\"_blank\" rel=\"noopener noreferrer\">PCB</a>, <a href=\"https://en.wikipedia.org/wiki/Process_control_block\" target=\"_blank\" rel=\"noopener noreferrer\">Process Control Block</a>). Kuvaajassa on tallessa kaikki prosessin käyttämät resurssit (ks. Luku 4). Prosessille avataan sen tarvitsemat tiedostot, laitteet ja verkkoyhteydet joko tässä yhteydessä etukäteen tai vasta prosessin suorituksen aikana. Tiedot kaikista aukiolevista tiedostoista, laitteista ja verkkoyhteyksistä ovat myös kuvaajassa. Kuvaajat ovat usein vakiokokoisia ja KJ tallettaa ne omalle muistialueelleen. Kuvaajalle ei siten yleensä tarvitse varata muistitilaa, vaan ainoastaan otetaan joku vapaana oleva kuvaaja uusiokäyttöön. Kuvaaja on (tietenkin) KJ:n omalla muistialueelle ja siihen voi viitata ainoastaan etuoikeutetussa suoritustilassa.</p><p>Prosessille varataan muistitilaa pinolle, keolle ja muiden prosessien kanssa yhteisille muistialueille sen latausmoduulissa annettujen määrittelyjen mukaisesti. Kaikki tiedot talletetaan kuvaajaan.</p><!-- kuva: ch-9-4-prosessi-pcb  --><p><img src=\"/db1db146cf05c4a7d4faf013123a266e/ch-9-4-prosessi-pcb.svg\" alt=\"Otsake Prosessi ja sen kuvaaja (PCB). Oikealla on iso laatikko, joka kuvaa muistia. Siinä on prosessin muistialueet PC, koodi ja pino. Vasemmalla on PCB suurennettuna ja siinä ensin kentät PID ja suoritinympäristö (PC, etc). Sitten varatut muistialueet (pcp, koodi, pino), joista kustakin on nuoli oikealla olevaan muistin vastaavaan alueeseen. Lopuksi PCB.ssä on kentät tiedostot, laitteet, verkkoyhteydet, CPU-prioriteetti, jne.  Alla on väylän takana massamuistina kovalevy, josta on varattu tietty määrä tilaa virtuaalimuistin tukimuistille.\"></p><div>\n<illustrations motive=\"ch-9-4-prosessi-pcb\"></illustrations>\n</div><p>Perusidea on, että <em>kaikki</em> yhteen prosessiin liittyvät tiedot löytyvät sen kuvaajasta (ja siihen linkitetyistä muista tietorakenteista). Sitten kun prosessi aikanaan poistetaan järjestelmästä, käyttöjärjestelmä voi kuvaajan tietojen perusteella vapauttaa kaikki prosessin käyttämät resurssit ja lopulta vapauttaa sen tunnisteen (PID) ja kuvaajan uusiokäyttöön.</p><p>Prosessin <em>suoritinympäristössä</em> (processor context) on arvot kaikille laiterekistereille, jotka pitää ladata, kun tämä prosessi aikanaan pääsee suoritukseen. Kun (jos) prosessi joutuu myöhemmin odottamaan mistä tahansa syystä, suoritinympäristö kopioidaan suorittimelta tänne sitä varten, että suoritus voisi joskus jatkua samasta kohtaa (samasta konekäskystä sen alusta pitäen) täsmälleen samassa ympäristössä kuin mitä se oli suorituksen keskeytyessä. Suoritinympäristöön kuuluvat kaikki rekisterit ja prosessin hallintaan liittyvät rekisterit em. tarkoitusta varten. Siihen sisältyvät esimerkiksi kaikki laskentaan tarvittavat työ- ja indeksirekisterit sekä erilaiset suorittimen kontrolliin liittyvät rekisterit, kuten paikanlaskuri PC, pinorekisteri SP, kekorekisteri HP, tilarekisteri SR, vertailujen tulosrekisterit CR, muistialueiden rajarekisterit BASE ja LIMIT, virtuaalimuistin sivutaulujen osoiterekisterit PT, jne.</p><p>Nyt prosessi on valmis ja järjestelmä tunnistaa sen uniikista PID:stä. Jos prosessin kaikki tarvittavat resurssit (esim. riittävä määrä keskusmuistia) on heti saatu käyttöön, prosessi voidaan siirtää R-to-R jonoon (valmis suoritukseen -jono, Ready-jono, Ready-to-Run-jono) odottamaan suoritusta suorittimella. Muussa tapauksessa prosessi laitetaan odotustilaan (esim. keskusmuistia odottavien prosessien jonoon), josta se sitten joskus myöhemmin resurssien vapauduttua pääsee R-to-R-jonoon odottamaan suoritusvuoroaan.</p><p>Prosessin kuvaajan tietoja ja prosessien hallintaa yleensä käsitellään tarkemmin yliopistojen käyttöjärjestelmäkursseilla.</p><text-box variant=\"example\" name=\"Historiaa: Ensimmäinen korkean tason kielen kääntäjä\">\nEnsimmäinen korkean tason kielen kääntäjä valmistui 1957 IBM:llä John Backuksen ryhmässä Fortran-kielelle IBM 704 -järjestelmälle. Fortrania on koko ajan kehitetty ajan mukaiseksi ja sitä voi nykyään käyttää niin lohkoperustaiseen ohjelmointiin kuin rinnakkaislaskentaa vaativiin tehtäviin. Ensimmäisen kääntäjän tekeminen kesti neljä vuotta. Kääntäjällä pystyi alusta pitäen tuottamaan optimoitua koodia, koska asiakkaat olivat tottuneet assemblerilla käsin koodattuun hyvin optimoituun koodiin.<p><img src=\"/25afa426c31b76e682a075b8f71be586/ch-9-4-ibm-704.svg\" alt=\"IBM 704 NACAn konesalissa 1957. NACA oli NASAn edeltäjä ja siitä tuli NASA 1958. Edessä on naispuolinen operaattori syöttämässä ohjelmaa reikäkortinlukijaan ja takana on miespuolinen insinööri tutkailemassa usean metrin mittaista ja puolitoista metriä korkeaa tietokonetta, josta etupaneelit on poistettu. Tietokoneen sisäinen langoitus on näkyvillä ja oikealla puolella on suuri noin 1m x 1m ohjauspaneeli.\"></p><div>\n<illustrations motive=\"ch-9-4-ibm-704\"></illustrations>\n</div></text-box><h2>Yhteenveto</h2><p>Tässä luvussa annoimme yleiskuvan siitä, kuinka ns. \"tavallisella\" korkean tason kielellä kirjoitetusta ohjelmasta saadaan järjestelmässä suoritettava prosessi. Ohjelman esitysmuotona on järjestelmän suorittimen ymmärtämä konekieli, joka annetaan suorittimelle koodina. Käännösmoduuleista saadaan eri ohjelmointikielistä <em>kääntämällä</em> kohdearkkitehtuurin konekielisiä objektimoduuleita. Niissä on kussakin uudelleensijoitustaulu, jonka avulla on määritelty liitokset kaikkiin muihin objektimoduuleihin. Objektimoduulit <em>linkitetään</em> yhteen osoiteavaruuteen latausmoduuliksi, josta <em>lataaja</em> sitten muodostaa käyttöjärjestelmän tunteman suorituskelpoisen prosessin. Eri ohjelmointikielten kääntäjät, staattiset ja dynaamiset linkittäjät sekä lataaja ovat normaaleja käyttöjärjestelmään sisältyviä peruspalikoita.</p><p>On myös olemassa toisen tyyppinen ohjelmien suoritustapa. Siinä suoritettava ohjelma annetaan datana (syötteenä) jollekin käyttöjärjestelmän tunnistamalle prosessille, joka voi olla esimerkiksi tulkki, emulaattori tai simulaattori. Suoritettavan ohjelman esitysmuoto voi olla esimerkiksi jotain skriptikieltä, jonkin toisen koneen konekieltä tai korkean tason kielen kääntäjän välikieltä. Tällaista ohjelmien suoritustapaa käsitellään seuraavassa luvussa 10.</p><p>Vastaa alla olevaan kyselyyn, kun olet opiskellut tämän luvun asiat.</p><!-- ### summary quizit lukuun 9 ??? --><div><quiz id=\"716f4349-3b44-54c0-921f-ce6bf474480e\"></quiz></div></div>","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}},"allPages":{"edges":[{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}