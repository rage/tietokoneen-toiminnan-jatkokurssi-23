{"componentChunkName":"component---src-templates-course-content-template-js","path":"/luku-8/3-io-toteutus","result":{"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Pääoppimistavoitteena tässä aliluvussa on esitellä I/O:n erilaiset toteutustavat ja mitä ne vaativat I/O-laitteen laiteohjaimelta. Esittelemme myös erilaiset tavat suorittimelle tunnistaa, viittaako jokin konekäsky keskusmuistiin vai laiteohjaimen muistiin (laiterekisteriin).\n"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Laiteohjain ja laiteajuri"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I/O:n toteutus on monimutkainen, koska siinä suoritetaan oikeasti täysin samanaikaisesti kahta eri prosessia, joiden tulee koordinoida toimintaansa keskenään. Työnjako on jaettu kahteen eri prosessiin: suorittimella suorittavaan laiteajuriin (DD, device driver) ja laiteohjaimella suorittavaan laiteohjainprosessiin (DCP, device controller process). Laiteajuri on osa käyttöjärjestelmää ja jokaista laiteohjainta (ja laitetta) varten on siihen sopiva laiteajuri."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laiteajuri pääsee suorittimelle suorittamaan aika ajoin, mutta DCP on periaatteessa suorituksessa koko ajan, koska laiteohjaimella ei ole mitään muuta tekemistä. Laiteajuri voi olla itsenäinen prosessi, jolloin käyttäjätason prosessin kutsuvat sitä viestein. Laiteajuri voi olla toteutettuna myös aliohjelmana, jolloin käyttäjäprosessit kutsuvat sitä aliohjelmien kutsukäskyillä tai SVC:llä. Tällöin laiteajuri suoritetaan osana käyttäjäprosessia. Joka tapauksessa laiteajuri (tai ainakin sen tärkeimmät osat) suoritetaan etuoikeutetussa tilassa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laiteohjaimella on kaksi rajapintaa, toinen järjestelmään päin ja toinen sen kontrolloimiin laitteisiin. Emme käsittele varsinaisten laitteiden (esim. kovalevy, näyttö, näppäimistö) ohjauslogiikkaa sen tarkemmin.  Rajapinta järjestelmään tapahtuu väylän kautta ja siihen liittyy kolme muistialuetta, joita yleensä kutsutaan kontrolli-, status- ja datarekistereiksi. Näitä voidaan kutsua myös kyseisen laitteen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"portiksi"}]},{"type":"text","value":". Suorittimella suorituksessa oleva laiteajuri voi viitata laiteohjaimen rekistereihin samalla tavalla kuin keskusmuistiinkin."}]},{"type":"comment","value":" kuva: ch-8-3-laiteohjain    "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/bf30d47c7e869baca6b93a7265bd2799/ch-8-3-laiteohjain.svg","alt":"Kaavakuva järjestelmästä, jossa on muisti, suoritin ja väylä. Muistissa on puskuri. Suorittimella on käyttäjäprosessi ja laiteajuri. Väylään on liitetty myös laiteohjain. Laiteohjaimen rajapinta väylälle koostuu data, kontrolli- ja statusrekistereistä. Laiteohjaimen ulkoiasten laitteiden rajapinnassa on kahden laittee ohjauslogiikat ja kumpaankin niistä on liitetty kovalevy. Laiteohjaimen toimintaa ohjaa siellä suorituksessa oleva laiteohjainprosssi."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-8-3-laiteohjain"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laiteohjaimen rekisterit ovat myös DCP:n viitattavissa, mistä voisi aiheutua samanaikaisuusongelmia. Esimerkiksi, jos sekä DD että DCP kirjoittaisivat täsmälleen yhtä aikaa samaan rekisteriin, niin lopputulos voisi olla sekava tai ainakin epämääräinen. Tämä mahdollisuus on vältetty ovelasti esimerkiksi sillä tavoin, että ainoastaan DD kirjoittaa kontrollirekisteriin ja ainoastaan DCP kirjoittaa status-rekisteriin. DD viestii DCP:lle kontrollirekisterin kautta ja DCP viestii laiteajurille statusrekisterin kautta."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Datarekisteri voi itse asiassa olla laitteesta riippuen hyvinkin suuri. Esimerkiksi levyohjaimien laiterekisterissä voi sijaita usea monen megatavun puskuri. Laiterekisteriä voivat lukea ja kirjoittaa sekä DD että DCP. Datarekisterin kirjoittamista ja lukemista synkronoidaan kontrolli- ja statusrekistereiden avulla, joten sen käyttö on mahdollista ilman samanaikaisuusongelmia."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Laiterekistereihin osoittaminen laiteajurista"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laiteajuri voi siis viitata laiteohjaimen rekistereihin samalla tavalla kuin keskusmuistiinkin. Tästä seuraa, että konekäskyissä pitää jollain tavoin määritellä, kumpaan muistiin (keskusmuistiin vai laiteohjaimen rekistereihin) ollaan viittaamassa."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"I/O-konekäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Yksi tapa on käyttää erityiskonekäskyjä, jolloin näiden käskyjen yhteydessä viittaus tapahtuu aina laiteohjaimen rekistereihin. Ttk-91 koneessa in- ja out-käskyt toimivat juuri näin. Esimerkiksi out-käsky kirjoittaa aina näytön datarekisteriin sen sijaan, että kirjoitettaisiin johonkin päin muistia."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"in  r1, =kbd\nout r2, =crt"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Intelin x86 arkkitehtuurissa on aivan vastaavat IN ja OUT käskyt. Esimerkiksi IN-käskyllä luetaan valitulta laitteelta 1, 2 tai neljä tavua dataa johonkin rekisteriin. Näitä käskyjä käyttämällä siis päätellään operaatiokoodin perusteella, mille laitteelle (keskusmuistiin vai laiteohjaimien rekistereihin) muistiviittaukset kohdistuvat."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I/O-konekäskyjen huonona puolena on niiden staattisuus. Ne on täytynyt suunnitella konekielen käskykannan suunnitteluaikana ja ne on toteutettu kiinteästi suorittimelle. Niitä ei voi myöhemmin muokata, eikä niitä voi tehdä lisää mahdollisia uusia I/O-laitteita varten."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Muistiinkuvattu I/O"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toinen tapa on käyttää "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"muistiinkuvattua I/O:ta"}]},{"type":"text","value":", jossa normaali ohjelman käyttämä muistiavaruus (muistiosoitteiden joukko) on jaettu kahteen osaan.  Esimerkiksi, jos 32-bittisen muistiosoitteen vasemmanpuolimmainen bitti on nolla (osoitteet 0x0000 0000-0x7FFF FFFF), niin kyseessä on keskusmuistiosoite, ja muutoin (osoitteet 0x8000 0000-0xFFFF FFFF) kyseessä on viittaus jonkin I/O-laitteen laiteohjaimelle. Jos bitit 24-30 (oikealta lukien) käytetään laitteen valitsemiseen, niin laitteita voisi olla 64 erilaista ja jokaiselle laitteelle jää vielä 24-bittiset osoitteet laiteohjaimen oman muistialueen (laiterekistereiden) viittaamiseen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Huonona piirteenä tässä on, että suuri osa ohjelman muistiavaruudesta (edellisessä esimerkissä 50%) on nyt varattu I/O-laitteille. Etuna on, että I/O-laitteita kontrolloidaan tavallisilla muistiviitekäskyillä (load, store). Uuden tyyppisiä laitteita on helppo lisätä järjestelmään, kunhan niille vain kirjoitetaan sopiva laiteajuri. Tämä on yleisin tapa ohjata laitteita."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"# uuden kirjoittimen 0x4 laiterekistereiden osoitteet\nPrinterControl  dc 0x84000001  # kontrollirekisterin osoite\nPrinterStatus   dc 0x84000002  # statusrekisterin osoite\nPrinterData     dc 0x84000003  # datarekisterin osoite\n\nCmdPrint  equ 1    # tulostuskomento\n\n...\n# tulosta luku 53 kirjoittimella 0x4\n     load r1, =53            ; kirjoita luku 53 datarekisteriin\n     store r1, (PrinterData)   ; kirjoittaa laiteohjaimen datarekisteriin\n     load r1, =CmdPrint\n     store r1, (PrinterControl)   ; anna tulostuskäsky laiteohjaimelle"}]}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"I/O-tyypit"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I/O-laitteet voidaan luokitella kolmeen eri tyyppiin sen mukaan, miten niiden laiteohjaimet on liitetty järjestelmään. Kaikki laiteohjaimet liitetään samaan väylähierarkiaan, mutta laitteiden funktionaalisuudessa on eroja."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Suora I/O (Direct I/O, Programmed I/O)"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kaikkein yksinkertaisin toteutus on suora I/O, jota käyttävät laitteet tarvitsevat väyläliittymän ainoastaan sen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"dataväylän"}]},{"type":"text","value":" osalta. Kuten luvussa 2 kerrottiin, niin väylän voi jakaa kolmeen komponenttiin: dataväylässä siirtyy data, osoiteväylässä muistiosoitteet ja kontrolliväylässä väylänhallintaan (ja I/O-laitekeskeytyksiin) liittyvät signaalit."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorassa I/O:ssa laiteajuri (DD) ohjaa koko toimintaa ja pysyy suorituksessa koko I/O-toiminnan ajan. Laiteajuri antaa laitteelle (sen laiteohjainprosessille, DCP:lle) komennon kirjoittamalla kyseinen komento laiteohjaimen kontrollirekisteriin. Sen jälkeen DD aktiivisesti pollaa (lukee) tilarekisterin arvoa, kunnes DCP on ilmoittanut annetun komennon tulleen suoritetuksi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laiteohjain ei siis käytä väylää lainkaan itse, vaan se kirjoittaa ja lukee omassa muistissaan olevia laiterekistereitä I/O:n toteuttamiseksi. Kun DCP on valmis uuteen I/O-tapahtumaan, se ensin nollaa (resetoi) tilarekisterin ja sitten pollaa (ikuisessa loopissa) kunnes tämän laitteen ajuri DD antaa sille uuden komennon."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oletetaan esimerkiksi, että uusi näppäimistö olisi toteutettu näin. Käytämme muistiinkuvattua I/O:ta ja näppäimistön laiterekisterien osoitteet laiteajurissa ovat KBControl (kontrollirekisteri), KBStatus (statusrekisteri) ja KBData (data rekisteri). Laiteohjaimen muistissa laiterekisterit ovat tavallisia muistipaikkoja Status, Control ja Data."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Näppäimistöltä voisi nyt lukea yhden merkin (yksinkertaistetun koodin avulla) seuraavanlaisesti:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Laiteajuri (DD) -- suora I/O\n----------------------------\n\n     load r1, =1          ; komento \"Lue\"\n     store r1, (KBControl)\n\nloop load r1, (KBStatus)  ; odota näppäintä, 1 = OK, negat. arvo = vika\n     jneg r1, KBError     ; näppäimistö rikki, ei kytketty, tms.\n     jzer r1, loop\n\n     load r1, (KBData)    ; lue merkki laitteelta datarekisteristä\n     store r1, Buffer     ; vie merkki keskusmuistiin puskuriin\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n     store r2, Data\n\n     load r1, =1         ; ilmoita ajurille\n     store r1, Status"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkin DCP suorittaa siis laiteohjaimella. Laiteohjaimen suoritin ei yleensä ole lainkaan samantyyppinen keskusyksikön suorittimen (CPU) kanssa eikä se käytä samanlaisia konekäskyjä. Yksinkertaisen laitteen laiteohjain voi olla suoraan toteutettuna mikropiireillä, jolloin mitään suoritinta tai laiteohjain"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"prosessia"}]},{"type":"text","value":" ei edes ole. Laitteen toimintaa voi silti hyvin kuvata DCP:n kaltaiseksi. Tässä esimerkissä laiteohjaimella on suoritin, jonka rakenne ja käskykanta ovat (pedagogista syistä) samanlaisia CPU:n kanssa. DCP voi viitata laiteohjaimen laiterekistereihin (sen muistiin) suoraan tavallisilla muistiosoitteilla. Esimerkistä on tahallaan jätetty pois yksityiskohdat, joilla merkki siirretään puskurista (Buffer) käyttäjätason prosessille ja joilla DCP pääsee seuraavan merkin lukemiseen. Samoin siitä on jätetty pois erilaisten virheiden käsittelyrutiinit."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorassa I/O:ssa etuna on, että se on hyvin yksinkertainen toteuttaa. Huonona puolena on se, että kaikki odotus tapahtuu suorittamalla tiukkaa silmukkaa, kunnes luettu tieto on halutun mukainen. DCP:llä tämä ei haittaa, koska se on muusta järjestelmästä irrallinen laite. Sillä ole mitään muutakaan tekemistä sillä aikaa, kun se odottaa jonkin prosessin haluavan käyttää sitä (esim. näppäimistöä)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorittimella suorituksessa oleva DD on eri asia. Koska oheislaite (esim. näppäimistö) voi olla hyvinkin hidas, niin odotusaika silmukassa voi olla suorittimen nopeuteen nähden hyvinkin pitkä, miljardeja looppeja. Esimerkiksi artikkelin kirjoittaja voi vaikka lähteä lounaalle tai nukkumaan välillä. Olisi järkevää, jos odotusaikana voisi tehdä jotain hyödyllistä. Hyödyllisiä tehtäviä voisi olla vaikkapa käyttöjärjestelmän hallinto tai kissavideon näyttäminen. Tähän ongelmaan vastauksena on seuraavaksi esiteltävä keskeyttävä I/O."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Keskeyttävä I/O (epäsuora I/O, indirect I/O, interrupt-driven I/O)"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Keskeyttävää I/O:ta käyttävä laiteohjain on kytketty dataväylän lisäksi myös "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kontrolliväylään"}]},{"type":"text","value":". Siellä on erityisesti yksi johdin varattu I/O-laitekeskeytykselle. Kun DCP kirjoittaa tuolle johtimelle (eli aiheuttaa I/O-laitekeskeytyksen), niin keskusyksikön suoritin havaitsee tämän heti nykyisen konekäskyn suorituksen jälkeen ja siirtyy suorittamaan siihen liittyvää keskeytyskäsittelijää."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DD voi nyt I/O-komennon annettuaan siirtyä odotustilaan ja järjestelmä voi suorittaa muita prosesseja odotusaikana. Kun DCP on lopulta saanut tehtävänsä tehtyä, niin se ensin kertoo siitä tilarekisterissä ja sitten aiheuttaa I/O-laitekeskeytyksen. Suorittimella suorituksessa oleva ohjelma suorittaa (etuoikeutetussa tilassa) nyt heti I/O-laitekeskeytyksen keskeytyskäsittelijän, joka siirtää DD:n odotustilasta Valmis suoritukseen -tilaan (Ready-tilaan). Käyttöjärjestelmän vuoronantopolitiikasta riippuen DD pääsee suoritukseen heti paikalla tai sitten vasta vähän ajan päästä. Sitten DD lukee statusrekisterin arvon ja päättää jatkotoimista tämän I/O-tapahtuman suhteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Aikaisempi esimerkin näppäimistö toimisi nyt seuraavanlaisesti:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Laiteajuri (DD) -- keskeyttävä I/O\n----------------------------------\n\n     load r1, =1           ; komento \"Lue\"\n     store r1, (KBControl) ; kirjoita komento kontrollirekisteriin\n\n     svc sp, =SLEEP        ; mene odotustilaan\n\n     ... ; herää henkiin sitten joskus, kun käyttöjärjestelmä päättää\n\n     load r1, (KBStatus)   ; lue status, 1 = OK, negat. arvo = vika\n     jneg r1, KBError      ; oliko jotain vialla?\n\n     load r1, (KBData)     ; lue merkki laitteelta\n     store r1, Buffer      ; vie se keskusmuistiin\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n     store r2, Data      ; kirjoita merkki datarekisteriin\n\n     load r1, =1         ; ilmoita merkistä ajurille\n     store r1, Status\n\n     load r1, =1         ; aiheuta I/O-laitekeskeytys, jotta\n     store r1, IOInt     ; ajuri pääsee joskus suoritukseen"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Keskeyttävän I/O:n yksi heikkous on sen suoraa I/O:ta hitaampi reagointinopeus. Suorassa I/O:ssa DD jatkaa suoritusta muutaman konekäskyä myöhemmin sen jälkeen, kun DCP on ilmoittanut sille annetun tehtävän valmistumisesta. Keskeyttävässä I/O:ssa pitää ensin suorittaa keskeytyskäsittelijä, joka siirtää DD:n Valmis suoritukseen -jonoon, josta se lopulta pääsee suoritukseen. Aikaa tähän kuluu vähintää yhden prosessin vaihdon verran. Lisäksi aikaa on kulunut yhden prosessin vaihdon verran, kun DD meni odotustilaan aikoinaan."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edellisen esimerkin DD:n kaksi viimeistä riviä näyttävät selkeästi näiden kahden I/O-tyypin yhteisen heikkouden. Kaikki data virtaa sana kerrallaan CPU-rekisterin kautta ja kaiken datan tarvitsee kulkea muistiväylän läpi kaksi kertaa. Jos siirrettävä datamäärä on pieni (muutama tavu tai sana), niin tästä ei ole haittaa. Mutta jos siirrettävänä on 4 KB tai 4 MB virtuaalimuistin sivu tai levylohko, niin tämä hidastaa I/O:ta tekevän prosessin ja koko järjestelmän suoritusta merkittävästi. Ongelman ratkaisu on seuraavaksi esiteltävä DMA-I/O."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"DMA I/O"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DMA I/O:ssa ("},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Direct_memory_access","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Direct Memory Access"}]},{"type":"text","value":") laiteohjain on vielä aikaisempia laitteita älykkäämpi. DMA-laiteohjain pystyy nyt siirtämään itse dataa keskusmuistin ja laiteohjaimen datarekisterin välillä, joten datan ei tarvitse kiertää CPU-rekisterien kautta. Datarekisteri voi näissä laitteissa olla hyvinkin suuri, sisältäen esimerkiksi 32 kappaletta 4 MB puskureita."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On mahdollista, että DMA-laite voi itse käyttää "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"osoiteväylää"}]},{"type":"text","value":" ja tehdä itsenäisesti datasiirtoja. Yleensä järjestelmässä on kuitenkin erityinen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"DMA-ohjain"}]},{"type":"text","value":", joka tekee tiedon siirron DMA-laitteiden puolesta. DMA-laitteen DCP pyytää tällöin DMA-laiteohjainta datasiirtoihin. Isommissa järjestelmissä tällainen keskitetty DMA-ohjain on parempi DMA:n toteutustapa, koska suurten DMA-datasiirtojen hallinta on vaikeata. Mikään laite ei saisi varata väylää liian pitkäksi aikaa, koska se hidastaa muiden prosessien suoritusta suorittimella. DMA-ohjainta käytettäessä kaikki DMA-laitteet toimivat samalla tavalla väylän käytön suhteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edellinen esimerkki ei ole hyvä DMA-laitteen osalta. Näppäimistöä ei mitenkään kannata toteuttaa DMA-I/O:n avulla, mutta jos näin tehtäisiin, niin esimerkkimme olisi seuraavanlainen."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Laiteajuri (DD) -- DMA I/O\n--------------------------\n\n     load r1, =Buffer     ; anna DCP:lle puskurin muistiosoite\n     store r1, (KBData)\n\n     load r1, =1          ; komento \"Lue\" kontrollirekisteriin\n     store r1, (KBControl)\n\n     svc sp, =SLEEP       ; mene odotustilaan\n\n     ... ; herää henkiin sitten joskus, kun käyttöjärjestelmä päättää\n\n     load r1, (KBStatus)  ; lue status, 1 = OK, negat. arvo = vika\n     jneg r1, KBError     ; oliko jotain vialla?\n\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n\n     store r2, &Data     ; talleta näppäinkoodi suoraan muistiin\n\n     load r1, =1         ; ilmoita ajurille\n     store r1, Status\n\n     load r1, =1         ; aiheuta I/O-laitekeskeytys, jotta\n     store r1, IOInt     ; ajuri pääsee joskus suoritukseen"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Todellisuudessa DMA-I/O:lla kerralla siirrettävä data on yleensä suuri. Esimerkiksi kerralla voisi siirtää koko 4 KB levylohkon. Jos kovalevyn laiteohjain toteutetaan DMA-I/O:lla keskeyttävän I/O:n asemesta, niin DMA-I/O tapahtuu nopeammin kahdesta syystä. Ensinnäkin, tuo 4 KB virtaa väylän läpi vain kerran. Toiseksi, yhdessä I/O tapahtumassa kerralla siirettävä datamäärä on DMA-I/O:ssa suurempi (esim. 4 KB) kuin keskeyttävässä I/O:ssa (esim. 256 B), joten laiteajurin tarvitsee puuttua harvemmin I/O:n johtamiseen. Älykkään DMA-laitteen DCP tekee pääosan työstä itsenäisesti. Jos siirrettävänä on vain yksi levylohko, niin DMA-laitteen laiteajuri aktivoituu vain kaksi kertaa. Ensin se pyytää DMA-laitetta siirtämään datan ja lopuksi se tarkistaa, että datasiirto on onnistunut."}]},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Historiaa:  Transistori ja mikropiiri"},"children":[{"type":"text","value":"\nTransistorin kehittivät W.B. Shockley, J. Bardeen ja W. Brattain Bell Labsin tutkimuskeskuksessa 1948. Se oli 1900-luvun tärkeimpiä teknisiä keksintöjä ja he saivat työstä Nobel-palkinnon vuonna 1956. J. Kilby ja R. Noyce kehittivät siitä integroidun piirin, jossa sekä transistorit että johtimet toteutettiin tasossa puolijohtimien avulla. Transistoreilla pystyttiin toteuttamaan sekä muisti että suorittimen logiikka. Kilbyn piiri oli ensimmäinen transistori (1958) ja hän sai siitä Nobel-palkinnon vuonna 2000. Noyce aloitti uransa Shockleyn yhtiössä ja oli perustamassa sekä Fairchild Semiconductor (1957) että Intel (1968) -yhtiöitä. Intel on edelleenkin maailman johtavia yrityksiä mikropiirien valmistamisessa. Ensimmäinen kaupallinen mikropiiri Intel 4004 julkistettiin 1971. Siinä oli 46 konekäskyä ja 16 kappaletta 4-bittisiä rekistereitä. Se oli suunniteltu japanilaisen Busicom-yhtiön tekemän laskimen toteutukseen."},{"type":"comment","value":" kuva: ch-8-1-ch-8-3-trans-mikropros    "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/25fb7e6e0d3a8d8c320cc4f75923013c/ch-8-3-trans-mikropros.svg","alt":"Vasemmalla kuva ensimmäisestä transitorissa. Se on asennettu (nyt) muovitelineeseen, jossa alhaalla on eri metalleja epämäääräisissä kerroksissa. Välissä on jokin eriste. Metallit on kytketty toisiinsa sekavalta näyttävien ohuempien ja paksumpien johtimien avulla. Oikealla on kuva Intel 4004 mikroprosessorista. Se on asennettu keraamisen eristeen päälle ja johtimet 16 alassojottavaan kuparijalkaan kulkevat keramiikan sisällä. "},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-8-3-trans-mikropros"},"children":[]},{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Yhteenveto"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tämä luvussa näytettiin ensin, kuinka virtuaalimuisti toimii ja kuinka se ratkaisee osaltaan keskusmuistin ja kovalevyn välisen suuren nopeuskuilun ongelmaa muistihierarkiassa. Seuraavaksi esiteltiin tiedostojärjestelmän päätoiminnot ja kuinka tiedostot voidaan toteuttaa erilaisilla massamuistilaitteilla. Pääasiassa keskityttiin kuitenkin kovalevyjen toteutukseen. Viimeisessä aliluvussa käytiin läpi eri tavat toteuttaa I/O millä tahansa laitteella. Erityisesti esiteltiin, kuinka I/O:n toteutus tehdään yhteistyöllä keskusyksikön suorittimella suorittavan laiteajurin ja oheislaitteen laiteohjaimella suorittavan laiteohjainprosessin avulla. Mitä viisaampi laiteohjain on, sitä suuremman osan työstä se tekee ja sitä enemmän suoritinaikaa laiteajurilta jää muille prosesseille keskusyksikön suorittimella."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vastaa alla olevaan kyselyyn, kun olet opiskellut tämän luvun asiat."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"da7ff6ee-6364-5091-acec-ff8cbc73e530"},"children":[]}]}]},"html":"<div><div>\n<lead>Pääoppimistavoitteena tässä aliluvussa on esitellä I/O:n erilaiset toteutustavat ja mitä ne vaativat I/O-laitteen laiteohjaimelta. Esittelemme myös erilaiset tavat suorittimelle tunnistaa, viittaako jokin konekäsky keskusmuistiin vai laiteohjaimen muistiin (laiterekisteriin).\n</lead>\n</div><h2>Laiteohjain ja laiteajuri</h2><p>I/O:n toteutus on monimutkainen, koska siinä suoritetaan oikeasti täysin samanaikaisesti kahta eri prosessia, joiden tulee koordinoida toimintaansa keskenään. Työnjako on jaettu kahteen eri prosessiin: suorittimella suorittavaan laiteajuriin (DD, device driver) ja laiteohjaimella suorittavaan laiteohjainprosessiin (DCP, device controller process). Laiteajuri on osa käyttöjärjestelmää ja jokaista laiteohjainta (ja laitetta) varten on siihen sopiva laiteajuri.</p><p>Laiteajuri pääsee suorittimelle suorittamaan aika ajoin, mutta DCP on periaatteessa suorituksessa koko ajan, koska laiteohjaimella ei ole mitään muuta tekemistä. Laiteajuri voi olla itsenäinen prosessi, jolloin käyttäjätason prosessin kutsuvat sitä viestein. Laiteajuri voi olla toteutettuna myös aliohjelmana, jolloin käyttäjäprosessit kutsuvat sitä aliohjelmien kutsukäskyillä tai SVC:llä. Tällöin laiteajuri suoritetaan osana käyttäjäprosessia. Joka tapauksessa laiteajuri (tai ainakin sen tärkeimmät osat) suoritetaan etuoikeutetussa tilassa.</p><p>Laiteohjaimella on kaksi rajapintaa, toinen järjestelmään päin ja toinen sen kontrolloimiin laitteisiin. Emme käsittele varsinaisten laitteiden (esim. kovalevy, näyttö, näppäimistö) ohjauslogiikkaa sen tarkemmin.  Rajapinta järjestelmään tapahtuu väylän kautta ja siihen liittyy kolme muistialuetta, joita yleensä kutsutaan kontrolli-, status- ja datarekistereiksi. Näitä voidaan kutsua myös kyseisen laitteen <em>portiksi</em>. Suorittimella suorituksessa oleva laiteajuri voi viitata laiteohjaimen rekistereihin samalla tavalla kuin keskusmuistiinkin.</p><!-- kuva: ch-8-3-laiteohjain    --><p><img src=\"/bf30d47c7e869baca6b93a7265bd2799/ch-8-3-laiteohjain.svg\" alt=\"Kaavakuva järjestelmästä, jossa on muisti, suoritin ja väylä. Muistissa on puskuri. Suorittimella on käyttäjäprosessi ja laiteajuri. Väylään on liitetty myös laiteohjain. Laiteohjaimen rajapinta väylälle koostuu data, kontrolli- ja statusrekistereistä. Laiteohjaimen ulkoiasten laitteiden rajapinnassa on kahden laittee ohjauslogiikat ja kumpaankin niistä on liitetty kovalevy. Laiteohjaimen toimintaa ohjaa siellä suorituksessa oleva laiteohjainprosssi.\"></p><div>\n<illustrations motive=\"ch-8-3-laiteohjain\"></illustrations>\n</div><p>Laiteohjaimen rekisterit ovat myös DCP:n viitattavissa, mistä voisi aiheutua samanaikaisuusongelmia. Esimerkiksi, jos sekä DD että DCP kirjoittaisivat täsmälleen yhtä aikaa samaan rekisteriin, niin lopputulos voisi olla sekava tai ainakin epämääräinen. Tämä mahdollisuus on vältetty ovelasti esimerkiksi sillä tavoin, että ainoastaan DD kirjoittaa kontrollirekisteriin ja ainoastaan DCP kirjoittaa status-rekisteriin. DD viestii DCP:lle kontrollirekisterin kautta ja DCP viestii laiteajurille statusrekisterin kautta.</p><p>Datarekisteri voi itse asiassa olla laitteesta riippuen hyvinkin suuri. Esimerkiksi levyohjaimien laiterekisterissä voi sijaita usea monen megatavun puskuri. Laiterekisteriä voivat lukea ja kirjoittaa sekä DD että DCP. Datarekisterin kirjoittamista ja lukemista synkronoidaan kontrolli- ja statusrekistereiden avulla, joten sen käyttö on mahdollista ilman samanaikaisuusongelmia.</p><h3>Laiterekistereihin osoittaminen laiteajurista</h3><p>Laiteajuri voi siis viitata laiteohjaimen rekistereihin samalla tavalla kuin keskusmuistiinkin. Tästä seuraa, että konekäskyissä pitää jollain tavoin määritellä, kumpaan muistiin (keskusmuistiin vai laiteohjaimen rekistereihin) ollaan viittaamassa.</p><h4>I/O-konekäskyt</h4><p>Yksi tapa on käyttää erityiskonekäskyjä, jolloin näiden käskyjen yhteydessä viittaus tapahtuu aina laiteohjaimen rekistereihin. Ttk-91 koneessa in- ja out-käskyt toimivat juuri näin. Esimerkiksi out-käsky kirjoittaa aina näytön datarekisteriin sen sijaan, että kirjoitettaisiin johonkin päin muistia.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">in  r1, =kbd\nout r2, =crt</code></pre></div><p>Intelin x86 arkkitehtuurissa on aivan vastaavat IN ja OUT käskyt. Esimerkiksi IN-käskyllä luetaan valitulta laitteelta 1, 2 tai neljä tavua dataa johonkin rekisteriin. Näitä käskyjä käyttämällä siis päätellään operaatiokoodin perusteella, mille laitteelle (keskusmuistiin vai laiteohjaimien rekistereihin) muistiviittaukset kohdistuvat.</p><p>I/O-konekäskyjen huonona puolena on niiden staattisuus. Ne on täytynyt suunnitella konekielen käskykannan suunnitteluaikana ja ne on toteutettu kiinteästi suorittimelle. Niitä ei voi myöhemmin muokata, eikä niitä voi tehdä lisää mahdollisia uusia I/O-laitteita varten.</p><h4>Muistiinkuvattu I/O</h4><p>Toinen tapa on käyttää <em>muistiinkuvattua I/O:ta</em>, jossa normaali ohjelman käyttämä muistiavaruus (muistiosoitteiden joukko) on jaettu kahteen osaan.  Esimerkiksi, jos 32-bittisen muistiosoitteen vasemmanpuolimmainen bitti on nolla (osoitteet 0x0000 0000-0x7FFF FFFF), niin kyseessä on keskusmuistiosoite, ja muutoin (osoitteet 0x8000 0000-0xFFFF FFFF) kyseessä on viittaus jonkin I/O-laitteen laiteohjaimelle. Jos bitit 24-30 (oikealta lukien) käytetään laitteen valitsemiseen, niin laitteita voisi olla 64 erilaista ja jokaiselle laitteelle jää vielä 24-bittiset osoitteet laiteohjaimen oman muistialueen (laiterekistereiden) viittaamiseen.</p><p>Huonona piirteenä tässä on, että suuri osa ohjelman muistiavaruudesta (edellisessä esimerkissä 50%) on nyt varattu I/O-laitteille. Etuna on, että I/O-laitteita kontrolloidaan tavallisilla muistiviitekäskyillä (load, store). Uuden tyyppisiä laitteita on helppo lisätä järjestelmään, kunhan niille vain kirjoitetaan sopiva laiteajuri. Tämä on yleisin tapa ohjata laitteita.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># uuden kirjoittimen 0x4 laiterekistereiden osoitteet\nPrinterControl  dc 0x84000001  # kontrollirekisterin osoite\nPrinterStatus   dc 0x84000002  # statusrekisterin osoite\nPrinterData     dc 0x84000003  # datarekisterin osoite\n\nCmdPrint  equ 1    # tulostuskomento\n\n...\n# tulosta luku 53 kirjoittimella 0x4\n     load r1, =53            ; kirjoita luku 53 datarekisteriin\n     store r1, (PrinterData)   ; kirjoittaa laiteohjaimen datarekisteriin\n     load r1, =CmdPrint\n     store r1, (PrinterControl)   ; anna tulostuskäsky laiteohjaimelle</code></pre></div><h3>I/O-tyypit</h3><p>I/O-laitteet voidaan luokitella kolmeen eri tyyppiin sen mukaan, miten niiden laiteohjaimet on liitetty järjestelmään. Kaikki laiteohjaimet liitetään samaan väylähierarkiaan, mutta laitteiden funktionaalisuudessa on eroja.</p><h4>Suora I/O (Direct I/O, Programmed I/O)</h4><p>Kaikkein yksinkertaisin toteutus on suora I/O, jota käyttävät laitteet tarvitsevat väyläliittymän ainoastaan sen <em>dataväylän</em> osalta. Kuten luvussa 2 kerrottiin, niin väylän voi jakaa kolmeen komponenttiin: dataväylässä siirtyy data, osoiteväylässä muistiosoitteet ja kontrolliväylässä väylänhallintaan (ja I/O-laitekeskeytyksiin) liittyvät signaalit.</p><p>Suorassa I/O:ssa laiteajuri (DD) ohjaa koko toimintaa ja pysyy suorituksessa koko I/O-toiminnan ajan. Laiteajuri antaa laitteelle (sen laiteohjainprosessille, DCP:lle) komennon kirjoittamalla kyseinen komento laiteohjaimen kontrollirekisteriin. Sen jälkeen DD aktiivisesti pollaa (lukee) tilarekisterin arvoa, kunnes DCP on ilmoittanut annetun komennon tulleen suoritetuksi.</p><p>Laiteohjain ei siis käytä väylää lainkaan itse, vaan se kirjoittaa ja lukee omassa muistissaan olevia laiterekistereitä I/O:n toteuttamiseksi. Kun DCP on valmis uuteen I/O-tapahtumaan, se ensin nollaa (resetoi) tilarekisterin ja sitten pollaa (ikuisessa loopissa) kunnes tämän laitteen ajuri DD antaa sille uuden komennon.</p><p>Oletetaan esimerkiksi, että uusi näppäimistö olisi toteutettu näin. Käytämme muistiinkuvattua I/O:ta ja näppäimistön laiterekisterien osoitteet laiteajurissa ovat KBControl (kontrollirekisteri), KBStatus (statusrekisteri) ja KBData (data rekisteri). Laiteohjaimen muistissa laiterekisterit ovat tavallisia muistipaikkoja Status, Control ja Data.</p><p>Näppäimistöltä voisi nyt lukea yhden merkin (yksinkertaistetun koodin avulla) seuraavanlaisesti:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Laiteajuri (DD) -- suora I/O\n----------------------------\n\n     load r1, =1          ; komento &quot;Lue&quot;\n     store r1, (KBControl)\n\nloop load r1, (KBStatus)  ; odota näppäintä, 1 = OK, negat. arvo = vika\n     jneg r1, KBError     ; näppäimistö rikki, ei kytketty, tms.\n     jzer r1, loop\n\n     load r1, (KBData)    ; lue merkki laitteelta datarekisteristä\n     store r1, Buffer     ; vie merkki keskusmuistiin puskuriin\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n     store r2, Data\n\n     load r1, =1         ; ilmoita ajurille\n     store r1, Status</code></pre></div><p>Esimerkin DCP suorittaa siis laiteohjaimella. Laiteohjaimen suoritin ei yleensä ole lainkaan samantyyppinen keskusyksikön suorittimen (CPU) kanssa eikä se käytä samanlaisia konekäskyjä. Yksinkertaisen laitteen laiteohjain voi olla suoraan toteutettuna mikropiireillä, jolloin mitään suoritinta tai laiteohjain<em>prosessia</em> ei edes ole. Laitteen toimintaa voi silti hyvin kuvata DCP:n kaltaiseksi. Tässä esimerkissä laiteohjaimella on suoritin, jonka rakenne ja käskykanta ovat (pedagogista syistä) samanlaisia CPU:n kanssa. DCP voi viitata laiteohjaimen laiterekistereihin (sen muistiin) suoraan tavallisilla muistiosoitteilla. Esimerkistä on tahallaan jätetty pois yksityiskohdat, joilla merkki siirretään puskurista (Buffer) käyttäjätason prosessille ja joilla DCP pääsee seuraavan merkin lukemiseen. Samoin siitä on jätetty pois erilaisten virheiden käsittelyrutiinit.</p><p>Suorassa I/O:ssa etuna on, että se on hyvin yksinkertainen toteuttaa. Huonona puolena on se, että kaikki odotus tapahtuu suorittamalla tiukkaa silmukkaa, kunnes luettu tieto on halutun mukainen. DCP:llä tämä ei haittaa, koska se on muusta järjestelmästä irrallinen laite. Sillä ole mitään muutakaan tekemistä sillä aikaa, kun se odottaa jonkin prosessin haluavan käyttää sitä (esim. näppäimistöä).</p><p>Suorittimella suorituksessa oleva DD on eri asia. Koska oheislaite (esim. näppäimistö) voi olla hyvinkin hidas, niin odotusaika silmukassa voi olla suorittimen nopeuteen nähden hyvinkin pitkä, miljardeja looppeja. Esimerkiksi artikkelin kirjoittaja voi vaikka lähteä lounaalle tai nukkumaan välillä. Olisi järkevää, jos odotusaikana voisi tehdä jotain hyödyllistä. Hyödyllisiä tehtäviä voisi olla vaikkapa käyttöjärjestelmän hallinto tai kissavideon näyttäminen. Tähän ongelmaan vastauksena on seuraavaksi esiteltävä keskeyttävä I/O.</p><h4>Keskeyttävä I/O (epäsuora I/O, indirect I/O, interrupt-driven I/O)</h4><p>Keskeyttävää I/O:ta käyttävä laiteohjain on kytketty dataväylän lisäksi myös <em>kontrolliväylään</em>. Siellä on erityisesti yksi johdin varattu I/O-laitekeskeytykselle. Kun DCP kirjoittaa tuolle johtimelle (eli aiheuttaa I/O-laitekeskeytyksen), niin keskusyksikön suoritin havaitsee tämän heti nykyisen konekäskyn suorituksen jälkeen ja siirtyy suorittamaan siihen liittyvää keskeytyskäsittelijää.</p><p>DD voi nyt I/O-komennon annettuaan siirtyä odotustilaan ja järjestelmä voi suorittaa muita prosesseja odotusaikana. Kun DCP on lopulta saanut tehtävänsä tehtyä, niin se ensin kertoo siitä tilarekisterissä ja sitten aiheuttaa I/O-laitekeskeytyksen. Suorittimella suorituksessa oleva ohjelma suorittaa (etuoikeutetussa tilassa) nyt heti I/O-laitekeskeytyksen keskeytyskäsittelijän, joka siirtää DD:n odotustilasta Valmis suoritukseen -tilaan (Ready-tilaan). Käyttöjärjestelmän vuoronantopolitiikasta riippuen DD pääsee suoritukseen heti paikalla tai sitten vasta vähän ajan päästä. Sitten DD lukee statusrekisterin arvon ja päättää jatkotoimista tämän I/O-tapahtuman suhteen.</p><p>Aikaisempi esimerkin näppäimistö toimisi nyt seuraavanlaisesti:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Laiteajuri (DD) -- keskeyttävä I/O\n----------------------------------\n\n     load r1, =1           ; komento &quot;Lue&quot;\n     store r1, (KBControl) ; kirjoita komento kontrollirekisteriin\n\n     svc sp, =SLEEP        ; mene odotustilaan\n\n     ... ; herää henkiin sitten joskus, kun käyttöjärjestelmä päättää\n\n     load r1, (KBStatus)   ; lue status, 1 = OK, negat. arvo = vika\n     jneg r1, KBError      ; oliko jotain vialla?\n\n     load r1, (KBData)     ; lue merkki laitteelta\n     store r1, Buffer      ; vie se keskusmuistiin\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n     store r2, Data      ; kirjoita merkki datarekisteriin\n\n     load r1, =1         ; ilmoita merkistä ajurille\n     store r1, Status\n\n     load r1, =1         ; aiheuta I/O-laitekeskeytys, jotta\n     store r1, IOInt     ; ajuri pääsee joskus suoritukseen</code></pre></div><p>Keskeyttävän I/O:n yksi heikkous on sen suoraa I/O:ta hitaampi reagointinopeus. Suorassa I/O:ssa DD jatkaa suoritusta muutaman konekäskyä myöhemmin sen jälkeen, kun DCP on ilmoittanut sille annetun tehtävän valmistumisesta. Keskeyttävässä I/O:ssa pitää ensin suorittaa keskeytyskäsittelijä, joka siirtää DD:n Valmis suoritukseen -jonoon, josta se lopulta pääsee suoritukseen. Aikaa tähän kuluu vähintää yhden prosessin vaihdon verran. Lisäksi aikaa on kulunut yhden prosessin vaihdon verran, kun DD meni odotustilaan aikoinaan.</p><p>Edellisen esimerkin DD:n kaksi viimeistä riviä näyttävät selkeästi näiden kahden I/O-tyypin yhteisen heikkouden. Kaikki data virtaa sana kerrallaan CPU-rekisterin kautta ja kaiken datan tarvitsee kulkea muistiväylän läpi kaksi kertaa. Jos siirrettävä datamäärä on pieni (muutama tavu tai sana), niin tästä ei ole haittaa. Mutta jos siirrettävänä on 4 KB tai 4 MB virtuaalimuistin sivu tai levylohko, niin tämä hidastaa I/O:ta tekevän prosessin ja koko järjestelmän suoritusta merkittävästi. Ongelman ratkaisu on seuraavaksi esiteltävä DMA-I/O.</p><h4>DMA I/O</h4><p>DMA I/O:ssa (<a href=\"https://en.wikipedia.org/wiki/Direct_memory_access\" target=\"_blank\" rel=\"noopener noreferrer\">Direct Memory Access</a>) laiteohjain on vielä aikaisempia laitteita älykkäämpi. DMA-laiteohjain pystyy nyt siirtämään itse dataa keskusmuistin ja laiteohjaimen datarekisterin välillä, joten datan ei tarvitse kiertää CPU-rekisterien kautta. Datarekisteri voi näissä laitteissa olla hyvinkin suuri, sisältäen esimerkiksi 32 kappaletta 4 MB puskureita.</p><p>On mahdollista, että DMA-laite voi itse käyttää <em>osoiteväylää</em> ja tehdä itsenäisesti datasiirtoja. Yleensä järjestelmässä on kuitenkin erityinen <em>DMA-ohjain</em>, joka tekee tiedon siirron DMA-laitteiden puolesta. DMA-laitteen DCP pyytää tällöin DMA-laiteohjainta datasiirtoihin. Isommissa järjestelmissä tällainen keskitetty DMA-ohjain on parempi DMA:n toteutustapa, koska suurten DMA-datasiirtojen hallinta on vaikeata. Mikään laite ei saisi varata väylää liian pitkäksi aikaa, koska se hidastaa muiden prosessien suoritusta suorittimella. DMA-ohjainta käytettäessä kaikki DMA-laitteet toimivat samalla tavalla väylän käytön suhteen.</p><p>Edellinen esimerkki ei ole hyvä DMA-laitteen osalta. Näppäimistöä ei mitenkään kannata toteuttaa DMA-I/O:n avulla, mutta jos näin tehtäisiin, niin esimerkkimme olisi seuraavanlainen.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Laiteajuri (DD) -- DMA I/O\n--------------------------\n\n     load r1, =Buffer     ; anna DCP:lle puskurin muistiosoite\n     store r1, (KBData)\n\n     load r1, =1          ; komento &quot;Lue&quot; kontrollirekisteriin\n     store r1, (KBControl)\n\n     svc sp, =SLEEP       ; mene odotustilaan\n\n     ... ; herää henkiin sitten joskus, kun käyttöjärjestelmä päättää\n\n     load r1, (KBStatus)  ; lue status, 1 = OK, negat. arvo = vika\n     jneg r1, KBError     ; oliko jotain vialla?\n\n\n\nLaiteohjainprosessi (DCP)\n-------------------------\n\n     load r1, =0          ; resetoi status\n     store r1, Status\n\nwait load r1, Control    ; odota kunnes uusi pyyntö\n     jnzer r1, wait\n\n     ...    ; odota, kunnes jotain näppäintä painettu.\n            ; painetun näppäimen koodi on r2:ssa\n\n     store r2, &amp;Data     ; talleta näppäinkoodi suoraan muistiin\n\n     load r1, =1         ; ilmoita ajurille\n     store r1, Status\n\n     load r1, =1         ; aiheuta I/O-laitekeskeytys, jotta\n     store r1, IOInt     ; ajuri pääsee joskus suoritukseen</code></pre></div><p>Todellisuudessa DMA-I/O:lla kerralla siirrettävä data on yleensä suuri. Esimerkiksi kerralla voisi siirtää koko 4 KB levylohkon. Jos kovalevyn laiteohjain toteutetaan DMA-I/O:lla keskeyttävän I/O:n asemesta, niin DMA-I/O tapahtuu nopeammin kahdesta syystä. Ensinnäkin, tuo 4 KB virtaa väylän läpi vain kerran. Toiseksi, yhdessä I/O tapahtumassa kerralla siirettävä datamäärä on DMA-I/O:ssa suurempi (esim. 4 KB) kuin keskeyttävässä I/O:ssa (esim. 256 B), joten laiteajurin tarvitsee puuttua harvemmin I/O:n johtamiseen. Älykkään DMA-laitteen DCP tekee pääosan työstä itsenäisesti. Jos siirrettävänä on vain yksi levylohko, niin DMA-laitteen laiteajuri aktivoituu vain kaksi kertaa. Ensin se pyytää DMA-laitetta siirtämään datan ja lopuksi se tarkistaa, että datasiirto on onnistunut.</p><text-box variant=\"example\" name=\"Historiaa:  Transistori ja mikropiiri\">\nTransistorin kehittivät W.B. Shockley, J. Bardeen ja W. Brattain Bell Labsin tutkimuskeskuksessa 1948. Se oli 1900-luvun tärkeimpiä teknisiä keksintöjä ja he saivat työstä Nobel-palkinnon vuonna 1956. J. Kilby ja R. Noyce kehittivät siitä integroidun piirin, jossa sekä transistorit että johtimet toteutettiin tasossa puolijohtimien avulla. Transistoreilla pystyttiin toteuttamaan sekä muisti että suorittimen logiikka. Kilbyn piiri oli ensimmäinen transistori (1958) ja hän sai siitä Nobel-palkinnon vuonna 2000. Noyce aloitti uransa Shockleyn yhtiössä ja oli perustamassa sekä Fairchild Semiconductor (1957) että Intel (1968) -yhtiöitä. Intel on edelleenkin maailman johtavia yrityksiä mikropiirien valmistamisessa. Ensimmäinen kaupallinen mikropiiri Intel 4004 julkistettiin 1971. Siinä oli 46 konekäskyä ja 16 kappaletta 4-bittisiä rekistereitä. Se oli suunniteltu japanilaisen Busicom-yhtiön tekemän laskimen toteutukseen.<!-- kuva: ch-8-1-ch-8-3-trans-mikropros    --><p><img src=\"/25fb7e6e0d3a8d8c320cc4f75923013c/ch-8-3-trans-mikropros.svg\" alt=\"Vasemmalla kuva ensimmäisestä transitorissa. Se on asennettu (nyt) muovitelineeseen, jossa alhaalla on eri metalleja epämäääräisissä kerroksissa. Välissä on jokin eriste. Metallit on kytketty toisiinsa sekavalta näyttävien ohuempien ja paksumpien johtimien avulla. Oikealla on kuva Intel 4004 mikroprosessorista. Se on asennettu keraamisen eristeen päälle ja johtimet 16 alassojottavaan kuparijalkaan kulkevat keramiikan sisällä. \"></p><div>\n<illustrations motive=\"ch-8-3-trans-mikropros\"></illustrations>\n</div></text-box><h2>Yhteenveto</h2><p>Tämä luvussa näytettiin ensin, kuinka virtuaalimuisti toimii ja kuinka se ratkaisee osaltaan keskusmuistin ja kovalevyn välisen suuren nopeuskuilun ongelmaa muistihierarkiassa. Seuraavaksi esiteltiin tiedostojärjestelmän päätoiminnot ja kuinka tiedostot voidaan toteuttaa erilaisilla massamuistilaitteilla. Pääasiassa keskityttiin kuitenkin kovalevyjen toteutukseen. Viimeisessä aliluvussa käytiin läpi eri tavat toteuttaa I/O millä tahansa laitteella. Erityisesti esiteltiin, kuinka I/O:n toteutus tehdään yhteistyöllä keskusyksikön suorittimella suorittavan laiteajurin ja oheislaitteen laiteohjaimella suorittavan laiteohjainprosessin avulla. Mitä viisaampi laiteohjain on, sitä suuremman osan työstä se tekee ja sitä enemmän suoritinaikaa laiteajurilta jää muille prosesseille keskusyksikön suorittimella.</p><p>Vastaa alla olevaan kyselyyn, kun olet opiskellut tämän luvun asiat.</p><div><quiz id=\"da7ff6ee-6364-5091-acec-ff8cbc73e530\"></quiz></div></div>","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}},"allPages":{"edges":[{"node":{"id":"18ee5500-1a93-508c-8462-3d890a7a581e","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"449322c9-010e-5f88-b706-71b86dbcf229","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"d0cf8b2a-ba5e-5144-ab17-2183dbc79e39","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"720db14d-0aac-57f0-8dea-1f1d45ab369b","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"20a26b21-ef5b-55d2-a2f2-03873a068c60","frontmatter":{"path":"/","title":""}}},{"node":{"id":"c647c4d9-7b26-5dde-92cf-2c0b6ab245bf","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"2a7139bf-80e6-52c5-854b-6b697e60a67c","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Usein kysytyt kysymykset"}}},{"node":{"id":"e2797a81-f19d-5fbc-b3f2-2d1c6541bfaf","frontmatter":{"path":"/luku-10/1-tulkitseminen-ohjelman-suoritustapana","title":"Tulkitseminen ohjelman suoritustapana"}}},{"node":{"id":"fbbeb9d5-47d8-5672-acd8-b5071048e0b5","frontmatter":{"path":"/luku-10/2-java-virtuaalikone","title":"Java virtuaalikone (JVM)"}}},{"node":{"id":"cb707bca-4404-5b81-8c54-a6e285112f42","frontmatter":{"path":"/luku-10/3-java-ohjelmien-suoritustavat","title":"Java-ohjelmien suoritustavat"}}},{"node":{"id":"2160c703-06b6-5b6c-b735-4bc48726112d","frontmatter":{"path":"/luku-10/4-emulointi-suorittimen-toteutustapana","title":"Emulointi suorittimen toteutustapana"}}},{"node":{"id":"9fa1e389-33b4-501f-b27a-d8574f90d88c","frontmatter":{"path":"/luku-10","title":"Luku 10: Tulkinta ja emulointi"}}},{"node":{"id":"3bf7644a-0bfc-5234-86ce-cd4324284a8e","frontmatter":{"path":"/luku-5/0-kertaus","title":"Perusteet-kurssin kertaus"}}},{"node":{"id":"befd446e-d2a6-54a3-8c21-5c25c35b69ef","frontmatter":{"path":"/luku-5/1-ttk-91","title":"Esimerkkitietokone ttk-91"}}},{"node":{"id":"e81b0755-960d-505b-8917-10b26f560bbb","frontmatter":{"path":"/luku-5/2-valinta-ja-toistolauseet","title":"Ohjelmoinnin peruskäsitteet sekä valinta- ja toistolauseiden toteutus"}}},{"node":{"id":"2ab512f6-9cf8-5051-bfb6-ee1c1fd811a7","frontmatter":{"path":"/luku-5/3-rakenteinen-tieto","title":"Rakenteisen tiedon toteutus ja siihen viittaaminen"}}},{"node":{"id":"884ea86c-429d-58cb-801a-3e3f4faa07f5","frontmatter":{"path":"/luku-5/4-optimoitu-koodi","title":"Optimoitu koodi"}}},{"node":{"id":"922be8ac-d049-5d41-804d-1a33d2136cf0","frontmatter":{"path":"/luku-5/5-titokone-titotrainer","title":"Titokone ja TitoTrainer"}}},{"node":{"id":"a663319d-ac43-5cca-a039-50f2a0957f36","frontmatter":{"path":"/luku-5","title":"Luku 5: Konekielinen ohjelmointi"}}},{"node":{"id":"3812cab3-1503-55b2-a2d3-84675b6ce79d","frontmatter":{"path":"/luku-6/1-aliohjelmat","title":"Aliohjelmat, parametrityypit, aktivaatiotietue (AT)"}}},{"node":{"id":"5589dc0e-45b5-530e-bd01-f70b5e6166c9","frontmatter":{"path":"/luku-6/2-akt-tiet-rakentaminen","title":"Aktivaatiotietueen rakentaminen"}}},{"node":{"id":"46e3432b-78dd-5983-987a-4ca0371bf031","frontmatter":{"path":"/luku-6/3-viiteparametrit","title":"Viiteparametrit ja ulostuloparametrit"}}},{"node":{"id":"0ee1147c-015e-5843-b858-942a5b0d33ca","frontmatter":{"path":"/luku-6/4-kj-palvelut","title":"Käyttöjärjestelmäpalvelujen käyttö"}}},{"node":{"id":"d2e3587c-8427-5cc9-979a-45c0f25d6f4b","frontmatter":{"path":"/luku-6","title":"Luku 6: Aliohjelmien toteutus"}}},{"node":{"id":"77083b55-f460-5cec-a1ce-746bd335a5f6","frontmatter":{"path":"/luku-7/1-vika-virhe-hairio","title":"Vika, virhe ja häiriö"}}},{"node":{"id":"fef01fef-b94c-5769-b39e-52e6d1d0b255","frontmatter":{"path":"/luku-7/2-tiedon-muuttumattomuus","title":"Tiedon muuttumattomuuden turvaaminen"}}},{"node":{"id":"d9fc9a0e-a6f9-5579-a1e5-06cab9086bf8","frontmatter":{"path":"/luku-7/3-muisti-cache-ssd","title":"Järjestelmän sisäisten muistien toteutus"}}},{"node":{"id":"29597c27-e1aa-52a0-a44d-73dfa913c3eb","frontmatter":{"path":"/luku-7","title":"Luku 7: Tiedon muuttumattomuus ja erilaiset muistit"}}},{"node":{"id":"9ad3d920-9960-59ca-8223-c6a68b4a9d97","frontmatter":{"path":"/luku-8/1-muistihierarkia","title":"Muistihierarkia ja virtuaalimuisti"}}},{"node":{"id":"d9007112-3ffb-5b61-b732-9ea67bb640c4","frontmatter":{"path":"/luku-8/2-tiedostot-massamuisti","title":"Tiedostojärjestelmä, tiedostot ja massamuisti"}}},{"node":{"id":"1724ec9e-2d62-51ff-8c41-113b97f504c7","frontmatter":{"path":"/luku-8/3-io-toteutus","title":"I/O:n toteutus"}}},{"node":{"id":"be08060b-e8b0-5032-abed-3a91d983d3c0","frontmatter":{"path":"/luku-8","title":"Luku 8: Ulkoisen muistin käyttö ja I/O:n toteutus"}}},{"node":{"id":"cc652698-287a-5e8d-bb09-40ef62a735f4","frontmatter":{"path":"/luku-9/1-lausekielesta-suoritukseen","title":"Lausekielestä suoritukseen"}}},{"node":{"id":"d92b88c2-3e0f-58c0-8440-864453030a8a","frontmatter":{"path":"/luku-9/2-kaantaminen","title":"Kääntäminen"}}},{"node":{"id":"5f49f9dd-29fc-50b9-88da-7f84b4c94d4d","frontmatter":{"path":"/luku-9/3-linkitys","title":"Linkitys"}}},{"node":{"id":"0a0d507b-2d34-52fc-b4eb-0df866230154","frontmatter":{"path":"/luku-9/4-lataus","title":"Lataus"}}},{"node":{"id":"5805c8b1-9b69-55c1-ad72-975455029d17","frontmatter":{"path":"/luku-9","title":"Luku 9: Käännös, linkitys ja lataus"}}}]}},"pageContext":{}},"staticQueryHashes":["2283872788","994120085"]}